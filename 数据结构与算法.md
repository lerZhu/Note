

# 数据结构与算法

## 1、稀疏数组

### 1.1、基本介绍

当一个数组中绝大元素为0，或者为同一个值时，可以用稀疏数组来保存该数组

稀疏数组的处理方法

1）记录数组一共有几行几列，有多少个不同的值

2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

ex：

![image-20210323195342543](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210323195342543.png)

### 1.2、思路分析

![image-20210323195506820](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210323195506820.png)

### 1.3、代码实现

```java
package com.company.sparsearray;

/**
 * @author zhulei
 * @create 2021-03-23 20:07
 */
public class SparseArray {
    public static void main(String[] args) {
        //创建原始二维数组
        //1代表黑子 2代表白子
        int row = 11;
        int column = 11;
        int chessArr[][] = new int[row][column];
        chessArr[1][2] = 1;
        chessArr[2][3] = 2;
        chessArr[4][5] = 2;
        System.out.println("原始的二维数组");
        for (int[] rows : chessArr) {
            for (int data : rows) {
                System.out.print(data + "\t");
            }
            System.out.println();
        }

        //将二维数组转为稀疏数组
        //遍历二维数组，得到非0个数
        int sum = 0;
        for (int[] rows : chessArr) {
            for (int data : rows) {
                if (data != 0){
                    sum++;
                }
            }
        }
        System.out.println("非零值个数：" + sum);

        //创建对应的稀疏数组
        int sparseArr[][] = new int[sum + 1][sum];
        sparseArr[0][0] = row;
        sparseArr[0][1] = column;
        sparseArr[0][2] = sum;

        //遍历二维数组，将非0值放入稀疏数组中
        int count = 0;//记录是第几个非0值
        for (int i = 0;i < 11;i++){
            for(int j = 0;j < 11;j++){
                if(chessArr[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr[i][j];
                }
            }
        }
        //输出稀疏数组
        System.out.println("稀疏数组");
        for (int[] ints : sparseArr) {
            for (int anInt : ints) {
                System.out.print(anInt + "\t");
            }
            System.out.println();
        }

        //把稀疏数组转为原始数组
        int restoreArr[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        for(int i = 1;i < sparseArr.length;i++){
            restoreArr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        //输出还原的数组
        System.out.println("还原的二维数组");
        for (int[] ints : restoreArr) {
            for (int anInt : ints) {
                System.out.print(anInt + "\t");
            }
            System.out.println();
        }
    }
}


```

运行结果：

```java
原始的二维数组
0	0	0	0	0	0	0	0	0	0	0	
0	0	1	0	0	0	0	0	0	0	0	
0	0	0	2	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	2	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
非零值个数：3
稀疏数组
11	11	3	
1	2	1	
2	3	2	
4	5	2	
还原的二维数组
0	0	0	0	0	0	0	0	0	0	0	
0	0	1	0	0	0	0	0	0	0	0	
0	0	0	2	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	2	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
```

## 2、队列

### 2.1、基本介绍

1）队列是有序列表，可用**数组**或是**链表**实现

2）**先入先出**原则

3）示意图：（数组模拟队列）

![image-20210323221709683](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210323221709683.png)

### 2.2、数组模拟队列

#### 2.2.1、思路

1）队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，maxSize是该队列的最大容量

2）因为队列的输出和输入分别是由前后端来处理，因此需要两个变量front和rear分别记录队列前后端的下标，front随着数据的输出改变，rear随着数据的输入改变。

3）把数据存入队列称为addQueue，此操作需要两个步骤

​	1.尾部指针后移：rear+1，当front==rear 【空】

​	2.若尾部指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear == maxS - 1 【队列满】

#### 2.2.2、数组模拟队列代码实现

```java
//使用数组模拟队列————编写一个ArrayQueue的类
class ArrayQueue {
    //数组最大容量
    private int maxSize;
    //数组前端下标
    private int front;
    //数组后端下标
    private int rear;
    //存放数据，模拟队列
    private int arr[];

    //构造器
    public ArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = -1;//指向队列头部
        rear = -1;//指向队列尾部
    }

    //判断队列是否满
    public boolean isFull() {
        return rear == maxSize - 1;
    }

    //判断队列是为空
    public boolean isEmpty() {
        return rear == front;
    }

    //给队列添加数据
    public void addQueue(int data) {
        if(isFull()){
            System.out.println("队列已满");
            return;
        }else {
            rear++;
            arr[rear] = data;
        }
    }

    //获取队列数据，出队列
    public int getQueue() {
        if(isEmpty()){
            throw new RuntimeException("队列为空");
        }else {
            front++;
            return arr[front];
        }
    }

    //显示队列所有数据
    public void showQueue() {
        if(isEmpty()){
            System.out.println("队列空，无数据");
            return;
        }
        for (int i : arr) {
            System.out.println(i);
        }
    }

    //显示队列头部数据，不是取数据
    public int showHead() {
        if(isEmpty()) {
            throw new RuntimeException("队列空，无数据");
        }
        return arr[front + 1];
    }
}
```

**问题**

- 数组不能复用 --> 改进成环形队列  **取模**

### 2.3、数组模拟环形队列

#### 2.3.1、思路

环形队列可用内存空间为maxSize-1，front指向队列头元素，rear指向队列尾元素后的一个空间。只入队时当front == rear时队列为空，front == rear+1时队列满。

1.令maxSize == 8 ，则可用内存为7
初始化队列front = 0；rear = 0；

由于front == rear 此时队列为空

![image-20210324222518891](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210324222518891.png)

2.不断向队列中添加元素，直到添加7个元素，此时最后一个元素为a6，rear的内存地址为a6后的空间。

仅入队时rear + 1 == front，故队列满。
考虑到实际存储有出入队情况，（rear + 1 ）%maxSzie== front ，才是真正的队列满

![image-20210324222637099](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210324222637099.png)

3.环形队列中元素的个数为：（rear-front+maxSize）%maxSize

![image-20210324222730487](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210324222730487.png)

#### 2.3.2、代码实现

```java
class circleArrayQueue{
    //队列最大容量
    private int maxSize;
    //队列的第一个元素
    private int front;
    //队列最后一个元素的后一个位置
    private int rear;
    //存放数据，模拟队列
    private int arr[];

    public circleArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
    }

    //判断队列是否满
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    //给队列添加数据
    public void addQueue(int data) {
        if (isFull()) {
            System.out.println("队列已满");
            return;
        } else {
            arr[rear] = data;
            rear = (rear + 1) % maxSize;
        }
    }

    //获取队列数据
    public int getQueue() {
        if(isEmpty()){
            throw new RuntimeException("队列为空");
        } else {
            int data = arr[front];
            front = (front + 1) % maxSize;
            return data;
        }
    }

    //显示队列所有数据
    public void showQueue() {
        if(isEmpty()) {
            System.out.println("队列为空");
            return;
        }else {
            for (int i = front;i < front + size();i++) {
                System.out.println(arr[i % maxSize]);
            }
        }
    }

    public int size() {
        return (rear + maxSize - front) % maxSize;
    }

    //显示头部数据
    public int headQueue() {
        if(isEmpty()) {
            throw new RuntimeException("队列为空");
        }else {
            return arr[front];
        }
    }

}
```

## 3、链表（Linked List）

### 3.1、基本介绍

链表是有序的列表，在内存中存储方式如下：

![image-20210324221453518](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210324221453518.png)

- 链表是以节点的方式来存储的，**链式存储**
- 每个节点包含data域、next域：指向下一个节点
- 链表**不是顺序存储**
- 链表分为带头节点和不带头节点的链表，根据实际需求来定

单链表（带头结点）逻辑结构示意图如下

![image-20210325205035211](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210325205035211.png)

### 3.2、单链表的实现

使用带head的单向链表实现水浒英雄排行榜完成对英雄人物的增删改查操作

1）第一种方法在添加英雄时直接添加到链表尾部

![image-20210325210640141](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210325210640141.png)

代码实现：

```java
//定义SingleLinkedList管理英雄
class SingleLinkedList{

    //初始化头结点
    private HeroNode head = new HeroNode(0," "," ");

    //添加节点到单向链表
    //当不考虑编号的顺序时
    //1.找到当前链表的最后一个节点
    //2.最后节点的next域指向新的节点
    public void addHero(HeroNode heroNode) {
        //因为head节点不能动，我们需要一个辅助遍历temp
        HeroNode temp = head;
        //遍历，找到链表最后一个节点
        while (true) {
            //找到链表最后
            if (temp.next == null){
                break;
            }else {
                //没有找到，将temp后移
                temp = temp.next;
            }
        }
        temp.next = heroNode;
    }

    //显示链表
    public void list() {
        //判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为head节点不能动，我们需要一个辅助遍历temp
        HeroNode temp = head.next;
        //遍历，找到链表最后一个节点
        while (true) {
            //找到链表最后
            if (temp == null){
                break;
            }else {
                //没有找到，将temp后移
                System.out.println(temp);
                temp = temp.next;
            }
        }
    }
}

//定义一个HeroNode，每个HeroNode对象就是一个节点
class HeroNode{

    public int no;
    public String name;
    public String nickName;
    public HeroNode next;

    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName +
                '}';
    }
}
```

2）第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果已经有这个排名，则添加失败，并给出提示）

![image-20210325213947655](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210325213947655.png)

代码实现：

```java
    //按排名顺序添加英雄
    public void addHeroByRank(HeroNode heroNode) {
        //因为head节点不能动，我们需要一个辅助遍历temp
        //因为是单链表，我们找的temp是位于添加位置的前一个节点，否则添加不了
        HeroNode temp = head;
        while (true) {
            if (temp.next == null){
                temp.next = heroNode;
                break;
            }else {
                if (temp.next.no == heroNode.no) {
                    System.out.println("已添加过该英雄" + heroNode.name);
                    break;
                }
                if (temp.next.no > heroNode.no) {
                    heroNode.next = temp.next;
                    temp.next = heroNode;
                    break;
                }
                //没有找到，将temp后移
                temp = temp.next;
            }
        }
    }
```

3）修改节点

```java
    //修改英雄信息
    public void update(HeroNode heroNode) {
        //判断是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点
        HeroNode temp = head;
        while (true) {
            if (temp.next == null) {
                System.out.println("没有找到该节点");
                break;
            }
            if (temp.next.no == heroNode.no) {
                temp.next.name = heroNode.name;
                temp.next.nickName = heroNode.nickName;
                break;
            }
            temp = temp.next;
        }
    }
```

4）删除节点

思路：

![image-20210325224756467](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210325224756467.png)

代码实现：

```java
    //删除节点
    public void delete(HeroNode heroNode) {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //找到需要删除的节点
        HeroNode temp = head;
        while (true) {
            if(temp.next == null) {
                System.out.println("没有找到该节点");
                break;
            }
            if(temp.next.no == heroNode.no) {
                temp.next = temp.next.next;
                break;
            }
            temp = temp.next;
        }
    }
```

### 3.3、单链表面试题

#### 1、获取单链表的节点个数，（如果带头结点，需要去除头结点）

```java
/**
* @param head 头结点
* @return  单链表节点个数
*/
public static int getLength(HeroNode head){
    //单链表没有节点
    if(head.next == null) {
        return 0;
    }
    int length = 0;
    //定义一个辅助变量
    HeroNode temp = head;
    while(true) {
        if(temp.next != null){
            length++;
        } else {
            return length;
        }
        temp = temp.next;
    }
}
```

#### 2、查找单链表的倒数第k个节点

```java
/**查找单链表的倒数第k个节点
 * @param head 头结点
 * @param index 倒数第index个
 * @return 节点
 */
public static HeroNode seekLastK(HeroNode head,int index){
    if (head.next == null) {
        System.out.println("链表为空");
        return null;
    }
    //先遍历链表，得到链表总长度
    int length = getLength(head);
    //判断index是否超过链表长度
    if(index > length || index <= 0) {
        System.out.println("index非法");
        return null;
    }
    HeroNode temp = head.next;
    //再遍历一次数组，遍历长度为length-index
    for (int i = 0; i < length - index; i++) {
        temp = temp.next;
    }
    return temp;
}
```

#### 3、单链表反转

```java
/**
 * 单链表反转
 * @param head 要反转的单链表
 */
public static void reversalSLL(HeroNode head) {
    //如果链表为空或者只有一个节点不需要反转
    if(head.next == null || head.next.next == null) {
        System.out.println("链表不需要反转");
        return;
    }
    //创建一个临时反转后链表的头结点
    HeroNode reversalSLLHead = new HeroNode(0,"","");
    //遍历原链表，每遍历一个就把该节点取出，插入反转链表的最前端
    HeroNode temp = head.next;
    while (true) {
        if (temp.next == null) {
            break;
        }else {
            //设置一个临时节点来存储temp的下一个节点，用于后面temp的后移
            HeroNode curr = temp.next;
            temp.next = reversalSLLHead.next;
            reversalSLLHead.next = temp;
            //temp后移
            temp = curr;
        }
    }
    //原来链表的head.next = reversalSLLHead.next
    head.next = reversalSLLHead.next;
}
```

#### 4、从尾到头打印链表

**利用栈先入后出的特性**

```java
/**
 * 从尾到头打印单链表 利用栈
 * @param head 需要倒序打印的单链表的头结点
 */
public static void reversePrint(HeroNode head) {
    //判断链表是否为空
    if(head.next == null){
        System.out.println("链表为空");
        return;
    }
    //创建一个栈
    Stack<HeroNode> heroNodes = new Stack<>();
    HeroNode temp = head.next;
    //遍历链表，入栈
    while (temp != null) {
        heroNodes.push(temp);
        temp = temp.next;
    }
    //出栈，输出
    while (heroNodes.size() > 0) {
        System.out.println(heroNodes.pop());
    }
}
```

#### 5、合并两个有序的单向链表，合并之后的链表依然有序

**创建一个新的链表，分别加入两个单链表，按顺序插入**

![image-20210407152834342](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210407152834342.png)

```java
/**
 * 合并两个有序的单向链表，合并之后的链表依然有序
 * @param head1 单向链表1
 * @param head2 单向链表2
 */
public static void merge(HeroNode head1,HeroNode head2){
    //创建一个新的链表
    SingleLinkedList singleLinkedList = new SingleLinkedList();
    HeroNode newHead = singleLinkedList.getHead();
    //如果两个链表中存在空链表
    if (head1.next == null || head2.next == null){
        if (head1.next == null && head2.next == null){
            System.out.println("两个空链表");
        }
        newHead.next = (head1.next != null)?head1.next:head2.next;
    }
    //把链表一加入新链表
    newHead.next = head1.next;
    //遍历链表二，将链表二的节点加入新链表
    HeroNode temp = head2.next;
    while (temp != null) {
        head2.next = temp.next;
        //temp指向链表二的下一个节点要消除，不然会插入一大串
        temp.next = null;
        singleLinkedList.addHeroByRank(temp);
        temp = head2.next;
    }

    singleLinkedList.list();
}
```

### 3.4、双向链表

#### 3.4.1、双向链表的分析和代码实现

使用带head的双向链表

单向链表缺点分析

- 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找
- 单向链表不能自我删除，需要依靠辅助节点，而双向链表可以自我删除，

![image-20210407163115761](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210407163115761.png)

1. 遍历：和单向链表一样，只是可以向前也可以向后
2. 添加（默认添加到链表的最后）
   1. 先找到双向链表的最后一个节点
   2. temp.next = newNode
   3. newNode.pre = temp
3. 修改：思路和单向链表一致
4. 删除
   1. 因为是双向链表，所以可以自我删除
   2. 直接找到要删除的节点，如temp
   3. temp.next.pre = temp.pre
   4. temp.pre.next = temp.next
   5. 要注意删除最后一个节点时，temp.next.pre会空指针

**代码实现**

节点类

```java
class Node{
    public int date;
    public Node pre;
    public Node next;

    public Node(int date) {
        this.date = date;
    }

    @Override
    public String toString() {
        return "Node{" +
                "date=" + date +
                '}';
    }
}
```

双向链表类

```java
class DoubleLinkedList{
    private Node head = new Node(0);

    //显示链表
    public void list() {
        //判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //遍历输出
        Node temp = head.next;
        while (temp != null) {
            System.out.println(temp);
            temp = temp.next;
        }
    }

    //添加节点
    //默认添加到链表最后
    public void addNode(Node node) {
        Node temp = head;
        while (true) {
            if (temp.next == null) {
                break;
            }else {
                temp = temp.next;
            }
        }
        temp.next = node;
        node.pre = temp;
    }

    //修改
    public void update(Node node,int data) {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点
        Node temp = head.next;
        while (temp != null) {
            if (temp.next == null) {
                System.out.println("没找到节点");
                break;
            }
            if(temp.date == node.date){
                temp.date = data;
                break;
            }
            temp = temp.next;
        }
    }

    //删除节点
    public void deleteNode(Node node) {
        if (head.next == null) {
            System.out.println("链表为空");
        }
        //找到需要删除的节点
        Node temp = head.next;
        while (true) {
            if(temp.date == node.date){
                //如果是最后一个节点，下面这句话会造成空指针
                if(temp.next != null) {
                    temp.next.pre = temp.pre;
                }
                temp.pre.next = temp.next;
                break;
            }
            if (temp.next == null){
                System.out.println("没找到节点");
                break;
            }
            temp = temp.next;
        }
    }
}
```

测试

```java
public class DoubleLinkedListDemo {
    public static void main(String[] args) {

        Node node1 = new Node(1123);
        Node node2 = new Node(232);
        Node node3 = new Node(3234);
        Node node4 = new Node(412);

        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.addNode(node1);
        doubleLinkedList.addNode(node2);
        doubleLinkedList.addNode(node3);
        doubleLinkedList.addNode(node4);

        doubleLinkedList.list();
        System.out.println("-------------------------");

        doubleLinkedList.update(node1,11);
        doubleLinkedList.list();
        System.out.println("-------------------------");

        doubleLinkedList.deleteNode(node4);
        doubleLinkedList.list();

    }
}
```

结果

```
Node{date=1123}
Node{date=232}
Node{date=3234}
Node{date=412}
-------------------------
Node{date=11}
Node{date=232}
Node{date=3234}
Node{date=412}
-------------------------
Node{date=11}
Node{date=232}
Node{date=3234}
```

### 3.5、单向环形链表应用场景

**Josephu问题**

Josephu问题为：设编号为1、2、3....n的n个人围坐成一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m的那个人出列，他的下一位又从1开始报数，数到m的那个人出列，以此类推，直到所有人出列为止，由此产生一个出队编号的序列。



提示：用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个节点的单循环链表，然后由k节点从1开始计数，计到m时，对应的节点从链表中删除，然后再从被删除节点的下一个节点从1开始计数，直到最后一个节点从链表中删除。

![image-20210408124957012](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210408124957012.png)

![image-20210408125012451](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210408125012451.png)

![image-20210408125020081](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210408125020081.png)

```java
package com.company.linkedlist;

/**
 * @author zhulei
 * @create 2021-04-08 9:33
 */
public class CircleLinkedListDemo {
    public static void main(String[] args) {
        CircleLinkedList circleLinkedList = new CircleLinkedList();
        circleLinkedList.add(5);
        circleLinkedList.list();
        System.out.println();

        circleLinkedList.countNode(1,2,5);
    }
}

class CircleLinkedList{

    private CircleNode first = null;

    /**
     * 添加节点，构成一个环形链表
     * @param nums 节点个数
     */
    public void add(int nums){
        if (nums < 1) {
            System.out.println("节点个数不符合要求");
            return;
        }
        //辅助指针，帮助构成环形链表
        CircleNode curNode = null;
        for (int i = 1; i <= nums; i++) {
            //根据编号，创建节点
            CircleNode node = new CircleNode(i);
            //如果是第一个节点
            if (i == 1) {
                first = node;
                //指向自己，构成环
                first.setNext(first);
                //辅助指针指向当前创建的节点
                curNode = first;
            }else {
                //辅助指针指向的是上一个创建的最后一个节点，将新节点连接到尾部
                curNode.setNext(node);
                //新节点连接到第一个节点，构成环
                node.setNext(first);
                //辅助指针指向当前创建的节点，后移
                curNode = node;
            }
        }
    }

    /**
     * 遍历当前链表
     */
    public void list() {
        if (first == null) {
            System.out.println("当前链表为空");
            return;
        }
        //因为first不能动，设置一个辅助指针来完成遍历
        CircleNode curNode = first;
        do {
            if (curNode.next == first){
                System.out.print(curNode.data);
                break;
            }
            System.out.print(curNode.data + " -> ");
            curNode = curNode.next;
        }while (curNode != first);
    }

    /**
     * 根据输入，计算出圈顺序
     * @param startNo 从第几号开始数
     * @param countNum 数了多少下
     * @param nums 最初有多少个数
     */
    public void countNode(int startNo,int countNum,int nums){
        //先对数据进行校验
        if (first == null || startNo < 1 || startNo > nums) {
            System.out.println("输入数据错误");
            return;
        }
        //创建辅助指针，
        CircleNode helper = first;
        //创建一个辅助指针变量helper，指向环形链表最后的节点
        while (true) {
            //说明helper指向最后一个节点
            if (helper.next == first) {
                break;
            }
            helper = helper.getNext();
        }
        //计数前，先让first和helper移动startNo-1次
        for (int i = 0; i < startNo - 1; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //计数是，让first和helper同时向后移动countNum-1次，然后出圈
        while (true) {
            //圈中只有一个节点
            if(helper  == first) {
                System.out.println(first.data);
                break;
            }
            //让first和helper同时向后移动countNum-1次
            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                helper = helper.getNext();
            }
            System.out.print(first.data + " -> ");
            first = first.getNext();
            helper.setNext(first);
        }
    }
}

class CircleNode{

    public int data;
    public CircleNode next;

    public void setNext(CircleNode next) {
        this.next = next;
    }

    public CircleNode getNext() {
        return next;
    }

    public CircleNode(int data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "CircleNode{" +
                "data=" + data +
                '}';
    }
}

输出结果：
1 -> 2 -> 3 -> 4 -> 5
2 -> 4 -> 1 -> 5 -> 3
```



## 4、栈（stack）

### 4.1、基本介绍

1. 栈的英文为stack
2. 栈是一个**先入后出**的有序列表
3. 栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊的线性表。允许插入和删除的一端，称为**栈顶（top）**，另一端为固定的一端，称为**栈底（bottom）**
4. 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除的元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

![image-20210408141652343](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210408141652343.png)

### 4.2、应用场景

1. 子程序调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后将地址取出，以回到原来的程序中
2. 处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中
3. 表达式的转换【中缀表达式转后缀表达式】与求值
4. 二叉树的遍历
5. 图形的深度优先搜索法

### 4.3、栈的实现

#### 1、用数组模拟栈

![image-20210408142039270](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210408142039270.png)

**代码实现**

```java
package com.company.stack;

/**
 * @author zhulei
 * @create 2021-04-08 13:00
 */
public class ArrayStackDemo {
    public static void main(String[] args) {
        ArrayStack arrayStack = new ArrayStack(10);
        arrayStack.push(1);
        arrayStack.push(2);
        arrayStack.push(3);
        arrayStack.list();
        System.out.println();
        arrayStack.pop();
        arrayStack.list();
    }
}

class ArrayStack{

    //栈最大容量
    private int maxSize;
    //数组模拟栈
    private int[] stack;
    //top表示栈顶，初始为-1
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //遍历,从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        for (int i = top;i >= 0;i--){
            System.out.println(stack[i]);
        }
    }

    //入栈
    public void push(int data){
        if (isFull()){
            System.out.println("栈已满");
            return;
        }
        top++;
        stack[top] = data;
    }

    //出栈
    public int pop(){
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        return stack[top--];
    }
}
```

#### 2、用链表模拟栈

```java
package com.company.stack;

/**
 * @author zhulei
 * @create 2021-04-08 13:26
 */
public class LinkedListStackDemo {
    public static void main(String[] args) {
        LinkedListStack linkedListStack = new LinkedListStack();
        linkedListStack.push(1);
        linkedListStack.push(2);
        linkedListStack.push(3);
        linkedListStack.list();
        System.out.println();

        linkedListStack.pop();
        linkedListStack.list();
    }
}

class LinkedListStack{

    private LLNode top;

    //入栈
    public void push(int data) {
        LLNode node = new LLNode(data);
        if (top == null) {
            top = node;
        }else {
            node.setNext(top);
            top = node;
        }
    }

    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        int data = top.getData();
        top = top.getNext();
        return data;
    }

    //输出栈顶元素，不是出栈
    public int showTop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        return top.getData();
    }

    //遍历栈
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        LLNode temp = top;
        while (true) {
            if (temp.getNext() == null) {
                System.out.println(temp.getData());
                break;
            }
            System.out.println(temp.getData());
            temp = temp.getNext();
        }
    }

    //栈空
    public boolean isEmpty() {
        return top == null;
    }
}

class LLNode{

    private int data;
    private LLNode next;

    public LLNode(int data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "LLNode{" +
                "data=" + data +
                '}';
    }

    public int getData() {
        return data;
    }

    public void setData(int data) {
        this.data = data;
    }

    public LLNode getNext() {
        return next;
    }

    public void setNext(LLNode next) {
        this.next = next;
    }
}
```

### 4.4、栈实现综合计算器（中缀表达式）

![image-20210408171122072](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210408171122072.png)

```java
package com.company.stack;

/**
 * @author zhulei
 * @create 2021-04-08 14:33
 */
public class Calculator {
    public static void main(String[] args) {
        String expression = "111+2*6-2";
        //创建两个栈。数栈、符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //扫描索引
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' ';//将每次扫描得到的char保存到ch中
        String keepNum = "";//用于拼接多位数
        while (true) {
            //一次得到expression中的每一个字符
            ch = expression.substring(index,index+1).charAt(0);
            //判断ch是什么
            if (operStack.isOper(ch)) {
                //判断当前的符号栈是否为空
                if (!operStack.isEmpty()) {
                    //如果符号栈有操作符，就进行比较
                    //如果当前的操作符的优先级小于或者等于栈中的操作符，就需要pop出两个数，从符号栈中pop出一个符号
                    //进行运算，将得到的结果入数栈，然后又将当前的操作符入符号栈
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        //进行运算，将得到的结果入数栈
                        res = numStack.cal(num1,num2,oper);
                        numStack.push(res);
                        //当前的操作符入符号栈
                        operStack.push(ch);
                    }else {
                        //如果当前的操作符的优先级大于栈中的操作符
                        operStack.push(ch);
                    }
                }else {
                    operStack.push(ch);
                }
            }else {
                //判断是几位数，处理时，向expression的表达式的index向后看一位，如果是数就进行扫描。是符号才入栈
                //定义一个字符串变量，用于拼接
                keepNum += ch;

                //如果ch是expression的最后一位，直接入栈
                if (index == expression.length() - 1){
                    numStack.push(ch);
                }else {
                    //判断下一个字符是不是数字，
                    //如果是数字，继续扫描
                    if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) {
                        numStack.push(Integer.parseInt(keepNum));
                        //清空keepNum
                        keepNum = "";
                    }
                }
            }
            //index+1,并判断是否扫描完成
            index++;
            if (index >= expression.length()) {
                break;
            }
        }
        //最后留在数栈中的数字就是结果
        while (true) {
            //如果符号栈为空，则计算到最后结果，数栈中只有一个数字
            if (operStack.isEmpty()) {
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            //进行运算，将得到的结果入数栈
            res = numStack.cal(num1,num2,oper);
            numStack.push(res);
        }
        System.out.println(expression + "=" + numStack.pop());
    }
}

class ArrayStack2{

    //栈最大容量
    private int maxSize;
    //数组模拟栈
    private int[] stack;
    //top表示栈顶，初始为-1
    private int top = -1;

    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //遍历,从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        for (int i = top;i >= 0;i--){
            System.out.println(stack[i]);
        }
    }

    //查看栈顶
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        return stack[top];
    }

    //入栈
    public void push(int data){
        if (isFull()){
            System.out.println("栈已满");
            return;
        }
        top++;
        stack[top] = data;
    }

    //出栈
    public int pop(){
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        return stack[top--];
    }

    //返回运算符优先级，数字越大，优先级越高
    public int priority(int oper) {
        if (oper == '*' || oper == '/') {
            return 1;
        }else if (oper == '+' || oper == '-') {
            return 0;
        } else {
            return -1;
        }
    }

    //判断是不是一个运算符
    public boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算方法
    public int cal(int num1, int num2,int oper) {
        int res = 0;
        switch (oper) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }

}
```

### 4.5、逆波兰计算器

1. 输入一个逆波兰表达式（后缀表达式），使用栈（stack），计算结果

2. 只支持整数

3. 思路

   **从左至右**扫描表达式，遇到数字时，将数字压入堆栈，

   遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；

   重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

4. 代码

```java
package com.company.stack;

import java.lang.annotation.ElementType;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * @author zhulei
 * @create 2021-04-09 9:06
 */
public class PolandNotation {

    public static void main(String[] args) {


        //先定义一个逆波兰表达式
        String suffixExpression = "33 4 + 5 * 6 -";

        List<String> listString = getListString(suffixExpression);

        System.out.println(suffixExpression + " = " + calculate(listString));

    }



    /**
     * 将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中
     * @param suffixExpression 要存入的表达式
     * @return 返回的List
     */
    public static List<String> getListString(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String ele : split) {
            list.add(ele);
        }
        return list;
    }

    /**
     * 完成对逆波兰表达式的计算
     * 1、从左至右进行扫描，将数字入栈
     * 2、遇到运算符，弹出栈顶元素和次顶元素，计算值，将结果入栈
     * 3、依次类推，最后留在栈中的是结果
     * @param list 要计算得表达式存入的list
     * @return 计算结果
     */
    public static int calculate(List<String> list) {
        //创建一个栈用来存放扫描到的数
        Stack<String> stack = new Stack<>();
        for (String item : list) {
            //用正则表达式来匹配数字
            if (item.matches("\\d+")) {
                //如果是数，入栈
                stack.push(item);
            }else {
                //创建两个临时变量来存放弹出的元素
                //栈顶元素
                int num1 = Integer.parseInt(stack.pop());
                //次顶元素
                int num2 = Integer.parseInt(stack.pop());
                //存放结果的变量
                int res = 0;
                switch (item) {
                    case "+":
                        res = num1 + num2;
                        break;
                    case "-":
                        res = num2 - num1;
                        break;
                    case "*":
                        res = num2 * num1;
                        break;
                    case "/":
                        res = num2 / num1;
                        break;
                    default:
                        System.out.println("运算符错误");
                        break;
                }
                //将结果入栈
                stack.push(""+res);
            }
        }
        //返回最后的计算结果
        return Integer.parseInt(stack.pop());
    }
}
```

### 4.6、中缀转后缀表达式

**具体步骤**

1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；

2. 从左至右扫描中缀表达式；

3. 遇到操作数时，将其压s2；

4. 遇到运算符时，比较其与s1栈顶运算符的优先级：

   (1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；

   (2)否则，若优先级比栈顶运算符的高，也将运算符压入s1；

   (3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较； 

5. 遇到括号时：

   (1)如果是左括号“(”，则直接压入s1
   (2)如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

6. 重复步骤2至5，直到表达式的最右边

7. 将s1中剩余的运算符依次弹出并压入s2

8. 依次弹出s2中的元素并输出，**结果的逆序即为中缀表达式对应的后缀表达式**

**举例说明**

将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下

| 扫描到的元素 | s2(栈底->栈顶)         | s1 (栈底->栈顶) | 说明                               |
| ------------ | ---------------------- | --------------- | ---------------------------------- |
| 1            | 1                      | 空              | 数字，直接入栈                     |
| +            | 1                      | +               | s1为空，运算符直接入栈             |
| (            | 1                      | + (             | 左括号，直接入栈                   |
| (            | 1                      | + ( (           | 同上                               |
| 2            | 1 2                    | + ( (           | 数字                               |
| +            | 1 2                    | + ( ( +         | s1栈顶为左括号，运算符直接入栈     |
| 3            | 1 2 3                  | + ( ( +         | 数字                               |
| )            | 1 2 3 +                | + (             | 右括号，弹出运算符直至遇到左括号   |
| ×            | 1 2 3 +                | + ( ×           | s1栈顶为左括号，运算符直接入栈     |
| 4            | 1 2 3 + 4              | + ( ×           | 数字                               |
| )            | 1 2 3 + 4 ×            | +               | 右括号，弹出运算符直至遇到左括号   |
| -            | 1 2 3 + 4 × +          | -               | -与+优先级相同，因此弹出+，再压入- |
| 5            | 1 2 3 + 4 × + 5        | -               | 数字                               |
| 到达最右端   | **1  2 3 + 4 × + 5 -** | 空              | s1中剩余的运算符                   |

因此结果为 "1 2 3 + 4 × + 5 –"

**代码实现**

```java
package com.company.stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * @author zhulei
 * @create 2021-04-09 10:18
 */
public class InfixToSuffix {

    public static void main(String[] args) {
        String expression  = "1+((2+3)*4)-5";
        //将字符串转换为对应的list
        List<String> list = toInfixExpressionList(expression);
        System.out.println(list);
        //中缀转后缀

        List<String> parseSuffixList = parseSuffixList(list);
        System.out.println(parseSuffixList);

        int calculate = PolandNotation.calculate(parseSuffixList);
        System.out.println(calculate);
    }

    /**
     * 中缀转后缀
     * @param list 中缀list
     * @return 后缀list
     */
    public static List<String> parseSuffixList(List<String> list) {
        //1、初始化两个栈
        Stack<String> s1 = new Stack<>();
        //因为s2在整个转换过程中没有pop操作，最后还需要逆序输出，直接使用list
        List<String> s2 = new ArrayList<>();
        //2、从左至右扫描中缀表达式
        for (String item : list) {
            //如果是一个数，加入到s2
            if (item.matches("\\d+")) {
                s2.add(item);
            }else if ("(".equals(item)){
                //如果是左括号，入s1
                s1.push(item);
            }else if (")".equals(item)) {
                //如果是右括号，依次弹出s1栈顶的运算符，并加入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while (!s1.peek().equals("(")) {
                    s2.add(s1.pop());
                }
                //弹出左括号
                s1.pop();
            }else {
                /*
                当item的优先级小于等于s1栈顶的运算符，
                将s1栈顶的运算符弹出并压入到s2中，
                再次比较item与s1新栈顶运算符优先级(需要一个比较优先级的方法)
                 */
                while (s1.size() != 0 && Operation.getValue(item) <= Operation.getValue(s1.peek())){
                    s2.add(s1.pop());
                }
                s1.push(item);
            }
        }

        //将s1中剩余的运算符依次弹出加入s2中
        while (s1.size() != 0){
            s2.add(s1.pop());
        }

        return s2;
    }

    /**
     * 将中追表达式转换成对应的list
     * @param s 要转换的中缀表达式
     * @return 转换得到的中缀list
     */
    public static List<String> toInfixExpressionList(String s) {
        //list用于存放中缀表达式对应的内容
        List<String> list = new ArrayList<>();
        //用于遍历中缀表达式字符串的指针
        int i = 0;
        String str;//对多位数拼接
        //每遍历一个字符，就存到c中
        char c;
        do {
            //如果c不是一个数字，直接加入list
            if ((c=s.charAt(i)) < 48 || (c=s.charAt(i)) > 57) {
                list.add("" + c);
                i++;
            }else {
                //先将str清空
                str = "";
                while (i < s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57) {
                    //拼接
                    str += c;
                    i++;
                }
                list.add(str);
            }
        }while (i < s.length());
        return list;
    }
}

//返回一个运算符对应的优先级
class Operation {

    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    public static int getValue(String operation) {
        int res = 0;
        switch (operation) {
            case "+":
                res = ADD;
                break;
            case "-":
                res = SUB;
                break;
            case "*":
                res = MUL;
                break;
            case "/":
                res = DIV;
                break;
            default:
                System.out.println("运算符错误");
                break;
        }
        return res;
    }
}
```

### 4.7、逆波兰计算器完整版

```java
package com.atguigu.reversepolishcal;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;



public class ReversePolishCalCase {

    public static void main(String[] args) {
//举例1: 2 + (3-4) => 2 3 4 - +
        //举例2: 4 * 5 - 8 + 60 + 8 / 2 = 4 5 * 8 - 60 + 8 2 / + 
        //举例3: (3+4)×5-6 => 3 4 + 5 * 6 -
//String suffixExperss = "4 5 * 8 - 60 + 8 2 / +";
//String suffixExperss = "2 3 4 - +";
//String suffixExperss = "3 4 + 5 * 6 -";
//
        ReversePolishCal reversePolishCal = new ReversePolishCal();
//
//List <String> suffixExpressionList = reversePolishCal.getListBySuffixExpression(suffixExperss);
//
//        System.out.println("计算结果:"+ reversePolishCal.calculate(suffixExpressionList));

        //测试输入中缀表达式是否能计算成功
        String infixExpression = "4*5-8+60+8/2";


        List<String> infixExpressionList = reversePolishCal.toInfixExpression(infixExpression);
        List<String> suffixExpressionList2 = reversePolishCal.parseSuffixExpression(infixExpressionList);
        //输出后缀表达式
        for(String ele : suffixExpressionList2) {
            System.out.print(ele + " ");
        }
        System.out.println();
        //输出结果
        System.out.println("计算结果:"+ reversePolishCal.calculate(suffixExpressionList2));


    }

}

class ReversePolishCal {

    /**
     * 把字符串转换成中序表达式 : 比如 2+(3-4), 并放入到List中
     * @param s
     * @return
     */
    public List<String> toInfixExpression(String infixExpression) {
        List<String> ls = new ArrayList<String>();//存储中序表达式
        int i = 0;
        String str;
        char c;
        do {
            //如果c 在 < 48 或者 > 57 说明是符号, 这里没有判断是 + , - , * , / 等等
            if ((c = infixExpression.charAt(i)) < 48 || (c = infixExpression.charAt(i)) > 57) {
                ls.add("" + c);
                i++;
            } else { // 说明是数字，要进行拼接处理
                str = "";
                while (i < infixExpression.length() && (c = infixExpression.charAt(i)) >= 48
                        && (c = infixExpression.charAt(i)) <= 57) {
                    str += c;
                    i++;
                }
                ls.add(str);
            }

        } while (i < infixExpression.length());
        return ls;
    }

    /**
     * 将一个中缀表达式对应的List 转成 转换成逆波兰表达式, 放入到List中
     * @param ls
     * @return
     */
    public  List<String> parseSuffixExpression(List<String> ls) {
        Stack<String> s1=new Stack<String>();
        Stack<String> s2=new Stack<String>();
        List<String> lss = new ArrayList<String>();
        for (String ss : ls) {
            if (ss.matches("\\d+")) {
                lss.add(ss);
            } else if (ss.equals("(")) {
                s1.push(ss);
            } else if (ss.equals(")")) {

                while (!s1.peek().equals("(")) {
                    lss.add(s1.pop());
                }
                s1.pop();
            } else {
                while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(ss)) {
                    lss.add(s1.pop());
                }
                s1.push(ss);
            }
        }
        while (s1.size() != 0) {
            lss.add(s1.pop());
        }
        return lss;
    }



    //将一个后缀表达式，依次放入到List<String>中
    public List<String> getListBySuffixExpression(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<String>();
        for (String element : split) {
            list.add(element);
        }
        return list;
    }

    /**
     *
     * @param ls 是一个按照逆波兰表达式得到衣蛾List 
     * @return
     */
    public int calculate(List<String> ls) {
        Stack<String> s=new Stack<String>();
        for (String str : ls) {
            if (str.matches("\\d+")) {
                s.push(str);
            } else {
                int b = Integer.parseInt(s.pop());
                int a = Integer.parseInt(s.pop());
                int result=0;
                if (str.equals("+")) {
                    result = a + b;
                } else if (str.equals("-")) {
                    result = a - b;
                } else if (str.equals("*")) {
                    result = a * b;
                } else if (str.equals("/")) {
                    result = a / b;
                } else {
                    throw new RuntimeException("符号错误");
                }
                s.push("" + result);
            }
        }
        //System.out.println(s.peek()); 
        return Integer.parseInt(s.pop());
    }


}


class Operation {
    private static int ADDITION=1;
    private static int SUBTRACTION=1;
    private static int MULTIPLICATION=2;
    private static int DIVISION=2;

    public static int getValue(String operation){
        int result;
        switch (operation){
            case "+":
                result=ADDITION;
                break;
            case "-":
                result=SUBTRACTION;
                break;
            case "*":
                result=MULTIPLICATION;
                break;
            case "/":
                result=DIVISION;
                break;
            default:
//                System.out.println("不存在该运算符");
                result=0;
        }
        return result;
    }
}
```

## 5、递归

### 5.1、递归应用场景

迷宫问题(回溯)， 递归(Recursion

![image-20210409195652728](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210409195652728.png)

### 5.2、递归的概念

递归就是方法自己调用自己,每次调用时传入不同的变量，递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。

### 5.3、递归的调用机制

1)打印问题

2)阶乘问题

```java
package com.company.recursion;

/**
 * @author zhulei
 * @create 2021-04-09 14:23
 */
public class RecursionTest {

    public static void main(String[] args) {
        test(5);

        int factorial = factorial(5);
        System.out.println(factorial);
    }

    public static void test(int n) {
        if (n > 2) {
            test(n - 1);
        }
        System.out.println("n=" + n);
    }

    public static int factorial(int n) {
        if (n == 1) {
            return 1;
        }else {
            return factorial(n - 1) * n;
        }
    }

}
```

### 5.4、递归需要遵守的规则

1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间)

2)方法的局部变量是独立的，不会相互影响, 比如n变量

3)如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.

4)递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)

5)当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### 5.5、递归-迷宫问题

**代码实现**

```java
package com.company.recursion;

/**
 * @author zhulei
 * @create 2021-04-09 15:31
 */
public class Labyrinth {
    public static void main(String[] args) {
        //先创建一个二维数组模拟迷宫
        //地图
        int[][] map = new int[8][7];
        //使用1表示墙
        //上下全部置为1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        //左右置为1
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }

        map[4][1] = 1;
        map[4][2] = 1;
        map[4][3] = 1;
        map[3][3] = 1;
        map[2][3] = 1;
        map[2][2] = 1;

        for (int[] ints : map) {
            for (int anInt : ints) {
                System.out.print(anInt + "\t");
            }
            System.out.println();
        }
        System.out.println("------------");

        setWay(map,1,1);

        for (int[] ints : map) {
            for (int anInt : ints) {
                System.out.print(anInt + "\t");
            }
            System.out.println();
        }
    }

    /**
     * 使用递归回溯给小球找路
     * @deprecated 如果小球能到（6,5），说明能找到通路，
     * 约定：当map[i][j]为0时表示该店没有走过，1表示墙，2表示通路可以走，3表示该点以及走过不能走
     * 走迷宫时，我们需要确定一个策略，下-》右-》上-》左，如果该点走不通，再回溯
     * @param map 地图
     * @param i
     * @param j （i，j）表示小球初始坐标
     * @return 找到为真
     */
    public static boolean setWay(int[][] map,int i,int j){
        //通络以及找到
        if (map[6][5] == 2) {
            return true;
        }else {
            if (map[i][j] == 0) {
                //假定该点可以走通
                map[i][j] = 2;
                if (setWay(map,i+1,j)) {//向下走
                    return true;
                }else if (setWay(map,i,j+1)){//向右走
                    return true;
                }else if (setWay(map,i-1,j)) {//向上走
                    return true;
                }else if (setWay(map,i,j-1)){//向左走
                    return true;
                }else {
                    //说明该点走不通，死路
                    map[i][j] = 3;
                    return false;
                }
            }else {
                return false;
            }
        }
    }
}
```

```java
1	1	1	1	1	1	1	
1	0	0	0	0	0	1	
1	0	1	1	0	0	1	
1	0	0	1	0	0	1	
1	1	1	1	0	0	1	
1	0	0	0	0	0	1	
1	0	0	0	0	0	1	
1	1	1	1	1	1	1	
------------
1	1	1	1	1	1	1	
1	2	2	2	2	0	1	
1	3	1	1	2	0	1	
1	3	3	1	2	0	1	
1	1	1	1	2	0	1	
1	0	0	0	2	0	1	
1	0	0	0	2	2	1	
1	1	1	1	1	1	1	
```

1)小球得到的路径，和程序员设置的找路策略有关即：找路的**上下左右**的顺序相关

2)再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化

3)测试回溯现象

### 5.6、递归-八皇后问题（回溯算法）

八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

**思路分析**

1)第一个皇后先放第一行第一列

2)第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适

3)继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解

4)当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.

5)然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 

说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列

**代码实现**

```java
package com.company.recursion;

import java.util.Map;

/**
 * @author zhulei
 * @create 2021-04-09 16:44
 */
public class Queue8 {
    //定义一个max表示有多少皇后
    int max = 8;
    //保存皇后位置放置的结果
    int[] arr = new int[max];
    static int count = 0;
    static int totalCount = 0;
    public static void main(String[] args) {
        Queue8 queue8 = new Queue8();
        queue8.check(0);
        System.out.println("一共有" + count + "种解法");
        System.out.println("一共执行了" + totalCount + "次");
    }

    private void check(int n) {
        if (n == max) { //8个皇后已经放完了
            print();
            return;
        }
        //依次放入皇后，判断是否冲突
        for (int i = 0; i < max; i++) {
            totalCount++;
            //先把当前皇后n，放到改行的第一列
            arr[n] = i;
            //判断当放置完成后是否冲突
            if (judge(n)) { //不冲突
                //接着放n+1个皇后
                check(n + 1);
            }
            //如果冲突，就继续执行arr[n] = 1，第n个皇后后移
        }
    }

    /**
     * 查看放置第n个皇后时，检测该皇后是否和前面已经摆放的皇后冲突
     * @param n 第n个皇后
     * @return 若不冲突，返回true
     */
    private boolean judge(int n) {
        for (int i = 0; i < n; i++) {
            //1.arr[i] == arr[n] 判断是否在同一列
            //2.Math.abs(n - i) == Math.abs(arr[n] - arr[i]) 判断是否在斜线上，45度斜线，函数
            if (arr[i] == arr[n] || Math.abs(n - i) == Math.abs(arr[n] - arr[i])){
                return false;
            }
        }
        return true;
    }

    /**
     * 输出皇后的位置
     */
    private void print() {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        count++;
        System.out.println();
    }
}
```

## 6、排序算法

### 6.1、排序分类

1. 内部排序

   将需要处理的数据全部加载到**内存**中进行排序

2. 外部排序

   **数据量过大**，无法全部加载到内存中，需要借助**外部存储**进行排序

3. 常见排序算法分类

- 排序
  - 内部排序
    - 插入排序
      - 直接插入排序
      - 希尔排序
    - 选择排序
      - 简单选择排序
      - 堆排序
    - 交换排序
      - 冒泡排序
      - 快速排序
    - 归并排序
    - 基数排序
  - 外部排序

### 6.2、冒泡排序

**基本介绍**

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。

**实现逻辑**

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

通过两层循环控制：

- 第一个循环（外循环），负责把需要冒泡的那个数字排除在外；
- 第二个循环（内循环），负责两两比较交换。

**演示**

![img](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

**代码实现**

```java
public static void bobbleSort(int arr[]) {
    int temp = 0;
    boolean flag = false;
    for (int i = 0;i < arr.length - 1;i++) {
        for (int j = 0;j < arr.length - i -1;j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] =temp;
                flag = true;
            }
        }
        if (!flag) {
            break;
        }else {
            flag = false;
        }
    }
}
```

### 6.3、选择排序

**选择排序(Selection sort)**是一种简单直观的排序算法。

**基本介绍**

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面，或者将最大值放在最后面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择，每一趟从前往后查找出无序区最小值，将最小值交换至无序区最前面的位置。

**实现逻辑**

① 第一轮从下标为 1 到下标为 n-1 的元素中选取最小值，若小于第一个数，则交换
② 第二轮从下标为 2 到下标为 n-1 的元素中选取最小值，若小于第二个数，则交换
③ 依次类推下去……

**演示**

![img](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

**代码实现**

```java
public static void selectSort(int[] arr){
    int min;
    int index = 0;
    for (int i = 0; i < arr.length - 1; i++) {
        min = arr[i];
        for (int j = i + 1; j < arr.length; j++) {
            if (min >= arr[j]) {
                min = arr[j];
                index = j;
            }
        }
        if(index != i){
            arr[index] = arr[i];
            arr[i] = min;
        }
    }
}
```

### 6.4、插入排序

**插入排序（Insertion-Sort）**的算法描述是一种简单直观的排序算法。打过扑克牌的应该都会明白

**基本介绍**

插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

![img](https://pic3.zhimg.com/80/v2-91dc753e1ddc5348eafd57ab24a8bab6_720w.png)

插入排序操作类似于摸牌并将其从大到小排列。每次摸到一张牌后，根据其点数插入到确切位置。

如上图：表示的是摸到草花7后进行插入的过程。忽略最右边的草花10，相当于一开始7在最右边，然后逐个与左边的排相比较(当然左边的牌早已排好顺序)，将其放置在合适的位置。当摸到草花10后重复上述过程即可。

而实际中，如何将插入牌的这个过程应用到实际排序操作中呢？具体我们以一组数字来说操作说明：

![img](https://pic1.zhimg.com/80/v2-8de71a6d88ccc5754deb89d58bcc8800_720w.jpg)

例如我们有一组数字：｛5，2，4，6，1，3｝，我们要将这组数字从小到大进行排列。 我们从第二个数字开始，将其认为是新增加的数字，这样第二个数字只需与其左边的第一个数字比较后排好序；在第三个数字，认为前两个已经排好序的数字为手里整理好的牌，那么只需将第三个数字与前两个数字比较即可；以此类推，直到最后一个数字与前面的所有数字比较结束，插入排序完成。

**实现逻辑**

① 从第一个元素开始，该元素可以认为已经被排序
② 取出下一个元素，在已经排序的元素序列中从后向前扫描
③如果该元素（已排序）大于新元素，将该元素移到下一位置
④ 重复步骤③，直到找到已排序的元素小于或者等于新元素的位置
⑤将新元素插入到该位置后
⑥ 重复步骤②~⑤

**演示**

![img](https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp)

**代码实现**

```java
    public static void insertSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            //要进行插入排序的数，暂存
            int insertValue = arr[i];
            //要进行插入的数的前一个坐标，开始比较的坐标
            int insertIndex = i - 1;
            //1、进行比较的坐标始终》=0，为了防止角标越界
            //2、进行排序的数小于扫描的数
            //被扫描到的数后移一位
            while (insertIndex >= 0 && insertValue < arr[insertIndex]) {
                //进行后移
                arr[insertIndex + 1] = arr[insertIndex];
                //继续扫描前一个数
                insertIndex--;
            }
            //找到需要插入的位置，把要排序的数进行插入
            //应为insertIndex在之前的循环中先--再跳出循环，所以需要+1再进行插入
            arr[insertIndex + 1] = insertValue;
        }
    }
```

**算法优化改进**

场景分析：

(1) 插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。

(2) 插入排序在每次往前插入时只能将数据移动一位，效率比较低。

改进思路：

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。

实际上就是希尔排序。

### 6.5、希尔排序

希尔排序的实质就是分组插入排序，该方法又称递减增量排序算法，因DL．Shell于1959年提出而得名。希尔排序是非稳定的排序算法。

**基本介绍**

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。

因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

**实现逻辑**

① 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。
② 所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。
③ 取第二个增量d2小于d1重复上述的分组和排序，直至所取的增量dt=1(dt小于dt-l小于…小于d2小于d1)，即所有记录放在同一组中进行直接插入排序为止。

**演示**

![img](https://pic1.zhimg.com/80/v2-7ef755d2b04f11cb013acb47f10928cc_720w.jpg)

假设有一组｛9, 1, 2, 5, 7, 4, 8, 6, 3, 5｝无需序列。

> **第一趟排序**： 设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。
> **第二趟排序**：
> 将上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为2组。按照直接插入排序的方法对每个组进行排序。
> **第三趟排序**：
> 再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为1的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。

*注：需要注意一下的是，图中有两个相等数值的元素5和5。我们可以清楚的看到，在排序过程中，两个元素位置交换了。*

**代码实现**

```java
public static void shellSort(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        //从第gap个元素开始，对其所在的组进行直接插入排序
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int temp = arr[j];
            while (j - gap >= 0 && temp < arr[j - gap]) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
    }
}
```

### 6.6、快速排序

快速排序，又称划分交换排序（partition-exchange sort）

**基本介绍**

通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

**实现逻辑**

快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

> ① 从数列中挑出一个元素，称为 “基准”（pivot），
> ② 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
> ③ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

**演示**

![img](https://pic2.zhimg.com/v2-d4e5d0a778dba725091d8317e6bac939_b.webp)

**代码实现**

```java
public static void quickSort(int[] arr,int left,int right) {
	int l = left;
    int r = right;
    int pivot = arr[(left + right) / 2];
    int temp = 0;
    while (l < r) {
        while (arr[l] < pivot) {
            l++;
        }
        while (arr[r] > pivot) {
            r--;
        }
        if (l >= r) {
            break;
        }

        temp = arr[l];
        arr[l] = arr[r];
        arr[r] = temp;

        if (arr[l] == pivot) {
            r--;
        }
        if (arr[r] == pivot) {
            l++;
        }
    }

    if (l == r) {
        l++;
        r--;
    }

    if (left < r) {
        quickSort(arr,left,r);
    }
    if (right > l) {
        quickSort(arr,l,right);
    }
}
```

### 6.7、归并排序

归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。

**基本介绍**

归并排序是用分治思想，分治模式在每一层递归上有三个步骤：

- **分解（Divide）**：将n个元素分成个含n/2个元素的子序列。
- **解决（Conquer）**：用合并排序法对两个子序列递归的排序。
- **合并（Combine）**：合并两个已排序的子序列已得到排序结果。

**实现逻辑**

**迭代法**

> ① 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
> ② 设定两个指针，最初位置分别为两个已经排序序列的起始位置
> ③ 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
> ④ 重复步骤③直到某一指针到达序列尾
> ⑤ 将另一序列剩下的所有元素直接复制到合并序列尾

**递归法**

> ① 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素
> ② 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素
> ③ 重复步骤②，直到所有元素排序完毕

**演示**

![img](https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp)

具体的我们以一组无序数列｛14，12，15，13，11，16｝为例分解说明，如下图所示：

![img](https://pic4.zhimg.com/80/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_720w.jpg)

上图中首先把一个未排序的序列从中间分割成2部分，再把2部分分成4部分，依次分割下去，直到分割成一个一个的数据，再把这些数据两两归并到一起，使之有序，不停的归并，最后成为一个排好序的序列。

**代码实现**

```java
/**
* 将待排序的数组进行分离
* @param arr 待排序的数组
* @param left 左边有序序列初始索引
* @param right 右边索引
* @param temp 临时数组，中转
*/
public static void mergerSort(int[] arr,int left,int right,int[] temp) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergerSort(arr,left,mid,temp);
        mergerSort(arr,mid+1,right,temp);

        merger(arr,left,mid,right,temp);
    }
}

/**
 *
 * @param arr 待排序数组
 * @param left 左边有序序列初始索引
 * @param mid 中间索引
 * @param right 右边索引
 * @param temp 临时数组，中转
 */
public static void merger(int[] arr,int left,int mid,int right,int[] temp) {
    int i = left;//初始化i，左边序列的初始索引
    int j = mid + 1;//初始化j，右边序列的初始索引
    int t = 0; //指向temp数组的当前索引

    //
    while (i <= mid && j <= right) {
        //如果左边有序序列当前元素小于或等于右边有序序列当前元素
        //就将左边的当前元素拷贝到temp数组
        //后移
        if (arr[i] <= arr[j]) {
            temp[t] = arr[i];
            t++;
            i++;
        }else { //反之，将右边的当前元素拷贝到temp数组
            temp[t] = arr[j];
            t++;
            j++;
        }
    }

    //左边有序序列还有数据剩余，全部填充到temp
    while (i <= mid) {
        temp[t] = arr[i];
        t++;
        i++;
    }
    while (j <= right) {
        temp[t] = arr[j];
        t++;
        j++;
    }

    t = 0;
    int tempLeft = left;
    while (tempLeft <= right) {
        arr[tempLeft] = temp[t];
        t++;
        tempLeft++;
    }
}
```

### 6.8、基数排序

基数排序（Radix sort）是一种非比较型整数排序算法。

**基本介绍**

原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

- **MSD**：先从高位开始进行排序，在每个关键字上，可采用计数排序
- **LSD**：先从低位开始进行排序，在每个关键字上，可采用桶排序

**实现逻辑**

① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
② 从最低位开始，依次进行一次排序。
③ 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

**演示**

![img](https://pic4.zhimg.com/80/v2-5ae4857fa248035ecec780583c5e3303_720w.jpg)

在上图中，首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。

- 按照个位数进行排序。
- 按照十位数进行排序。
- 按照百位数进行排序。

排序后，数列就变成了一个有序序列。

**代码实现**

```java
//辅助函数，求出最大位数
public static int maxBit(int[] arr) {
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return (max + "").length();
}

public static void radixSort(int[] arr) {
    
    //创建10个桶，每个桶的长度是arr.length,防止溢出
    int[][] bucket = new int[10][arr.length];
    //记录每个桶中实际存放了几个数据
    int[] count = new int[10];

    //循环最大位数次
    for (int i = 0, n = 1; i < maxBit(arr); i++,n *= 10) {
        for (int j = 0; j < arr.length; j++) {
            //去出档次循环位数上的大小
            int digitOfElement = arr[j] / n % 10;
            //把数据放入对应的桶中
            bucket[digitOfElement][count[digitOfElement]] = arr[j];
            //桶中数据数量+1
            count[digitOfElement]++;
        }
        //回返到arr的辅助下标
        int index = 0;
        //遍历每一个桶，并将桶中的数据放入到原数组
        for (int j = 0; j < count.length; j++) {
            //如果桶中有数据，放入原数组
            if (count[j] != 0) {
                //循环该桶
                for (int k = 0; k < count[j]; k++) {
                    arr[index] = bucket[j][k];
                    index++;
                }
            }
            //将桶中的计数清零
            count[j] = 0;
        }
    }
}
```

### 6.9、堆排序

堆一般指的是二叉堆，顾名思义，二叉堆是完全二叉树或者近似完全二叉树

#### 1、堆得相关概念

1. **堆的性质**

> ① 是一棵完全二叉树
> ② 每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。

2. **堆的存储**

一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)

![image-20210416095128125](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210416095128125.png)

3. **堆的操作**

在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：

> ① **最大堆调整（Max_Heapify）**：将堆的末端子节点作调整，使得子节点永远小于父节点
> ② **创建最大堆（Build_Max_Heap）**：将堆所有数据重新排序
> ③ **堆排序（HeapSort）**：移除位在第一个数据的根节点，并做最大堆调整的递归运算

#### 2、堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

**1.基本思想**

利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。

> ① 将待排序的序列构造成一个最大堆，此时序列的最大值为根节点
> ② 依次将根节点与待排序序列的最后一个元素交换
> ③ 再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列

**2. 实现逻辑**

> ① 先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素。
> ② 再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key
> ③ 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。
> ④ 直到无序区只有一个元素为止。

**3. 动图演示**

![img](https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.webp)

堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。

**分步解析说明**：

实现堆排序需要解决两个问题：

> 1、如何由一个无序序列建成一个堆？
> 2、如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？

假设给定一个组无序数列{100,5,3,11,6,8,7}，带着问题，我们对其进行堆排序操作进行分步操作说明。

![img](https://pic4.zhimg.com/80/v2-acbdde7cf6f0426e693187c4899716e7_720w.png)

**3.1 创建最大堆**

①首先我们将数组我们将数组从上至下按顺序排列，转换成二叉树：一个无序堆。每一个三角关系都是一个堆，上面是父节点，下面两个分叉是子节点，两个子节点俗称左孩子、右孩子；

![image-20210416095631497](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210416095631497.png)

②转换成无序堆之后，我们要努力让这个无序堆变成最大堆(或是最小堆)，即每个堆里都实现父节点的值都大于任何一个子节点的值。

![image-20210416095653286](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210416095653286.png)

③从最后一个堆开始，即左下角那个没有右孩子的那个堆开始；首先对比左右孩子，由于这个堆没有右孩子，所以只能用左孩子，左孩子的值比父节点的值小所以不需要交换。如果发生交换，要检测子节点是否为其他堆的父节点，如果是，递归进行同样的操作。

④第二次对比红色三角形内的堆，取较大的子节点，右孩子8胜出，和父节点比较，右孩子8大于父节点3，升级做父节点，与3交换位置，3的位置没有子节点，这个堆建成最大堆。

![image-20210416095724827](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210416095724827.png)

⑤对黄色三角形内堆进行排序，过程和上面一样，最终是右孩子33升为父节点，被交换的右孩子下面也没有子节点，所以直接结束对比。

⑥最顶部绿色的堆，堆顶100比左右孩子都大，所以不用交换，至此最大堆创建完成。

![img](https://pic4.zhimg.com/80/v2-cf88501a8092e7b0c4712aa81a875f03_720w.jpg)

**3.2 堆排序（最大堆调整）**

①首先将堆顶元素100交换至最底部7的位置，7升至堆顶，100所在的底部位置即为有序区，有序区不参与之后的任何对比。

![image-20210416095840538](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210416095840538.png)

②在7升至顶部之后，对顶部重新做最大堆调整，左孩子33代替7的位置。

![img](https://pic2.zhimg.com/80/v2-5bbfec3cb200b9fa7efcf29fe71fc7dd_720w.jpg)

③在7被交换下来后，下面还有子节点，所以需要继续与子节点对比，左孩子11比7大，所以11与7交换位置，交换位置后7下面为有序区，不参与对比，所以本轮结束，无序区再次形成一个最大堆。

![img](https://pic2.zhimg.com/80/v2-1f490e927a5d7d5e97e9609f7e99b6e5_720w.jpg)

④将最大堆堆顶33交换至堆末尾，扩大有序区；

![img](https://pic1.zhimg.com/80/v2-d77c2cf77a7b81041fba5871979f3910_720w.jpg)

⑤不断建立最大堆，并且扩大有序区，最终全部有序。

![img](https://pic3.zhimg.com/80/v2-724e54aaff73bd4c0bf5e5352fc673ce_720w.jpg)

#### 3、代码实现

```java
package com.company.sort;

import java.util.Arrays;

public class HeapSort {
    public static void main(String[] args) {
        //要求将数组进行升序
        int[] arr = new int[]{4,6,8,5,9};
        heapSort(arr);
    }

    /**
     * 堆排序
     * @param arr
     */
    public static void heapSort(int[] arr) {

//        adjustHeap(arr,1,arr.length);
//        System.out.println("第一次" + Arrays.toString(arr));
//
//        adjustHeap(arr,0,arr.length);
//        System.out.println("第二次" + Arrays.toString(arr));

        int temp = 0;

        //将无序序列构成一个堆，根据升序还是降序需求选择大顶堆或小顶堆
        //从最后一个非叶子结点开始，从左至右，从下至上进行调整
        //第一个非叶子结点 arr.length / 2 - 1
        for (int i = arr.length / 2 - 1; i >= 0 ; i--) {
            adjustHeap(arr,i,arr.length);
        }

        /*
        将堆顶元素与末尾元素交换，将最大元素沉到数组末端
        重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素
        反复执行调整+交换步骤，直到整个序列有序
         */
        for (int j = arr.length - 1; j > 0 ; j--) {
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr,0,j);
        }
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 将一个数组（二叉树），调整成一个大顶堆
     *
     * @param arr 待调整的数组
     * @param i 表示非叶子结点在数组中的索引
     * @param length 对多少个元素进行调整，length在逐渐减少
     */
    public static void adjustHeap(int[] arr,int i,int length) {
        //先取出当前元素的值，保存在零时变量
        int temp = arr[i];

        //k = i * 2 + 1是i节点的左子节点
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            //左子节点的值小于右子节点的值
            if (k + 1 < length && arr[k] < arr[k + 1]) {
                //k指向右子节点
                k++;
            }
            //如果右子节点大于当前节点
            if (arr[k] > temp) {
                //把较大值赋给当前节点
                arr[i] = arr[k];
                //i指向k，继续循环比较
                i = k;
            }else {
                break;
            }
        }

        //当for循环结束后，我们已经将以i为父节点的树的最大值，放在了最顶部
        arr[i] = temp;
    }
}
package com.company.sort;

import java.util.Arrays;

public class HeapSort {
    public static void main(String[] args) {
        //要求将数组进行升序
        int[] arr = new int[]{4,6,8,5,9};
        heapSort(arr);
    }

    /**
     * 堆排序
     * @param arr
     */
    public static void heapSort(int[] arr) {

//        adjustHeap(arr,1,arr.length);
//        System.out.println("第一次" + Arrays.toString(arr));
//
//        adjustHeap(arr,0,arr.length);
//        System.out.println("第二次" + Arrays.toString(arr));

        int temp = 0;

        for (int i = arr.length / 2 - 1; i >= 0 ; i--) {
            adjustHeap(arr,i,arr.length);
        }

        for (int j = arr.length - 1; j > 0 ; j--) {
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr,0,j);
        }
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 将一个数组（二叉树），调整成一个大顶堆
     *
     * @param arr 待调整的数组
     * @param i 表示非叶子结点在数组中的索引
     * @param length 对多少个元素进行调整，length在逐渐减少
     */
    public static void adjustHeap(int[] arr,int i,int length) {
        int temp = arr[i];

        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            if (k + 1 < length && arr[k] < arr[k + 1]) {
                k++;
            }
            if (arr[k] > temp) {
                arr[i] = arr[k];
                i = k;
            }else {
                break;
            }
        }

        arr[i] = temp;
    }
}
```

### 6.10、总结与对比

![image-20210412110707819](C:\Users\朱磊\AppData\Roaming\Typora\typora-user-images\image-20210412110707819.png)



## 7、查找算法

### 7.1、线性查找

顺序查找适合于存储结构为顺序存储或链接存储的线性表。

**基本思想**

从数据列中的一段开始（通常是起始位置），顺序扫描，依次比较所扫描数和目标值，如果相等则查找成功。若扫描结束仍没有找到那么就查找失败。

**代码实现**

```java
public static int seqSearch(int[] arr, int value) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == value) {
            return i;
        }
    }
    return -1;
}
```

### 7.2、二分查找

**元素必须是有序的**，如果是无序的则要先进行排序操作。

**基本思想**

也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

**代码实现**

```java
public static int binarySearch(int[] arr,int left,int right,int value) {
    //没找到
    if (left > right) {
        return -1;
    }
	
    //取中间值
    int mid = (left + right) / 2;
    int midValue = arr[mid];

    if (value > midValue) {//如果需要找的值比中间值大，向右递归
        return binarySearch(arr,mid+1,right,value);
    }else if (value < midValue) {//如果需要找的值比中间值小，向左递归
        return binarySearch(arr,left,mid-1,value);
    }else {//需要找的值与中间值相等，找到了
        return mid;
    }
}
```

如果表中有相同的值

```java
public static List<Integer> binarySearch2(int[] arr, int left, int right, int value) {
    //没找到
    if (left > right) {
        return null;
    }

    int mid = (left + right) / 2;
    int midValue = arr[mid];

    if (value > midValue) {//向右递归
        return binarySearch2(arr,mid+1,right,value);
    }else if (value < midValue) {//向左递归
        return binarySearch2(arr,left,mid-1,value);
    }else {//找到了
        //建一个集合用来存放找到的数的下标
        List<Integer> resultIndex = new ArrayList<>();
        //向左找
        int temp = mid - 1;
        while (true) {
            //如果左边没有发现与目标值相等的值，跳出
            if (temp < 0 || arr[temp] != value) {
                break;
            }
            resultIndex.add(temp);
            temp--;
        }
        resultIndex.add(mid);
        //向右找
        temp = mid + 1;
        while (true) {
            if (temp > arr.length - 1 || arr[temp] != value) {
                break;
            }
            resultIndex.add(temp);
            temp++;
        }
        return resultIndex;
    }
}
```

### 7.3、插值查找

插值查找就是对二分查找的优化，更改了mid的算法

**基本思想**

基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。

注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

mid = left + (right - left) *(key - a[left]) / (a[right] - a[left])

**代码实现**

```java
public static int insertSearch(int[] arr,int left,int right,int value) {
    System.out.println("hello");
    //防止mid越界
    if (left > right || value < arr[0] || value > arr[arr.length-1]) {
        return -1;
    }
	
    //求出mid，自适应
    int mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]);

    int midValue = arr[mid];

    if (value > midValue) {
        return insertSearch(arr,mid + 1,right,value);
    }else if (value < midValue) {
        return insertSearch(arr,left,mid - 1,value);
    }else {
        return mid;
    }
}
```

### 7.4、斐波那契查找

斐波那契查找的前提是待查找的查找表必须**顺序存储并且有序**

**基本思想**

也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。

　　相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：

　　1）相等，mid位置的元素即为所求

　　2）>，low=mid+1;

​        3）<，high=mid-1。

　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;

 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种

　　1）相等，mid位置的元素即为所求

　　2）>，low=mid+1,k-=2;

　　说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。

　　3）<，high=mid-1,k-=1。

　　说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。

![img](https://img-blog.csdn.net/20150323100632467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlbmJvMjAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**代码实现**

```java
public static int fibSearch(int[] arr,int key){
    int low = 0;
    int high = arr.length - 1;
    int k = 0; //表示斐波那契分割数值的下标
    int mid = 0;
    int f[] = fib();

    while (high > f[k] - 1) {
        k++;
    }
    //因为f[k]的值可能大于arr的长度，我们需要构建一个新的数组
    //不足的部分用arr的最后的值进行补充
    int[] temp = Arrays.copyOf(arr,f[k]);
    //使用arr最后的数填充temp
    for (int i = high + 1; i < temp.length; i++) {
        temp[i] = arr[high];
    }
    while (low <= high) {
        mid = low + f[k - 1] - 1;
        //low=mid+1说明待查找的元素在[low,mid-1]范围内，
        //k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，
        if (key < temp[mid]) {
            high = mid - 1;
            k--;
        }else if (key > temp[mid]) {
            low = mid + 1;
            k -= 2;
        }else {
            if (mid <= high){
                return mid;
            }else {
                return high;
            }
        }
    }
    return -1;
}

//的带==得到一个斐波那契数列
public static int[] fib() {
    int[] f = new int[maxSize];
    f[0] = 1;
    f[1] = 1;
    for (int i = 2; i < maxSize; i++) {
        f[i] = f[i - 1] + f[i -2];
    }
    return f;
}
```

## 8、哈希表

### 8.1、基本介绍

哈希表（Hash Table，也叫散列表），是根据关键码值（k-v）来直接进行访问额数据结构。也就是说，它用过把关键码值映射到一个表中的一个位置来访问记录，以加快查找的速度。这个映射函数叫散列函数，存放记录的数组叫做散列表。

![image-20210413162958854](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413162958854.png)

![image-20210413163011411](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413163011411.png)

### 9.2、一个实际应用题

有一个公司，当有新员工来报道时，要求将该员工的信息加入（id，性别，年龄，地址，姓名，住址），当输入该员工的id时，要求找到该员工的所有信息

**要求：**

1. 不使用数据库，速度越快越好=》哈希表
2. 添加时，保证按照id从低到高插入
3. 使用链表来实现哈希表，该链表不带表头
4. 思路

![image-20210413163517957](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413163517957.png)

```java
package com.company.hashTable;
import java.util.Scanner;

public class HashTabDemo {
    public static void main(String[] args) {
        HashTable hashTable = new HashTable(7);

        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.println("add:添加");
            System.out.println("list:显示");
            System.out.println("search:查找");
            System.out.println("delete:删除");
            System.out.println("exit:退出");
            System.out.println("--------");

            int id;
            key = scanner.next();
            switch (key){
                case "a":
                    System.out.println("输入id");
                    id = scanner.nextInt();
                    System.out.println("输入name");
                    String name = scanner.next();
                    Emp emp = new Emp(id, name);
                    hashTable.addEmp(emp);
                    break;
                case "l":
                    hashTable.list();
                    break;
                case "s":
                    System.out.println("输入id");
                    id = scanner.nextInt();
                    hashTable.getEmpById(id);
                    break;
                case "d":
                    System.out.println("输入id");
                    id = scanner.nextInt();
                    hashTable.deleteById(id);
                    break;
                case "e":
                    scanner.close();
                    System.exit(0);
                default:
                    break;
            }
        }
    }
}

//创建hashtab
class HashTable{
    private EmpLinkedList[] empLinkedListArray;
    private int size;

    public HashTable(int size) {
        this.size = size;
        this.empLinkedListArray = new EmpLinkedList[size];
        //分别初始化每一条链表,否则会出现空指针
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
    }

    /**
     * 添加员工
     * @param emp 待添加的员工
     */
    public void addEmp(Emp emp){
        //根据员工的id得到该员工应该加入哪个链表
        int empLinkedListNo = hashFun(emp.id);
        //将emp加入到对应的链表中
        empLinkedListArray[empLinkedListNo].add(emp);
    }

    /**
     * 遍历HashTab
     */
    public void list(){
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i].list(i);
        }
    }

    /**
     * 根据id查找员工
     * @param id 要查找的员工的id
     * @return 查找到的员工的id
     */
    public void getEmpById(int id) {
        int empLinkedListNo = hashFun(id);
        Emp emp = empLinkedListArray[empLinkedListNo].getEmpById(id);
        if (emp == null) {
            System.out.println("没找到该员工");
        }else {
            System.out.println(emp);
        }
    }

    /**
     * 通过id删除雇员
     * @param id 需要删除的雇员的id
     */
    public void deleteById(int id) {
        int empLinkedListNo = hashFun(id);
        int i = empLinkedListArray[empLinkedListNo].deleteEmpById(id);
        if (i == 1) {
            System.out.println("删除成功");
        }else {
            System.out.println("删除失败");
        }
    }

    /**
     * 散列函数
     * @param id 需要映射的id
     * @return 映射后的id
     */
    public int hashFun(int id) {
        return id % size;
    }
}

class Emp{

    public int id;
    public String name;
    public Emp next;

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Emp{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}

class EmpLinkedList{
    //头指针，指向第一个雇员，因此这个链表的head是有效的
    private Emp head = null;

    /**
     * 添加员工
     * @param emp 添加的员工
     */
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        }
        Emp temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = emp;
    }

    /**
     * 遍历当前链表
     */
    public void list(int i) {
        if (head == null) {
            System.out.println("第" + i + "条链表为空");
            return;
        }
        System.out.println("第" + i + "条链表信息为：");
        Emp temp = head;
        while (true) {
            System.out.print(temp);
            if (temp.next == null) {
                break;
            }
            temp = temp.next;
        }
        System.out.println();
    }

    /**
     * 通过id查找雇员
     * @param id 查找雇员的id
     * @return 找到的雇员
     */
    public Emp getEmpById(int id) {
        if (head == null) {
            return null;
        }
        Emp temp = head;
        while (true) {
            if (temp.id == id) {
                break;
            }
            if (temp.next == null) {
                temp = null;
                break;
            }
            temp = temp.next;
        }
        return temp;
    }

    /**
     * 通过id删除guy
     * @param id 需要删除的雇员的id
     * @return -1,删除失败；1,删除成功
     */
    public int deleteEmpById(int id){
        //头结点为空
        if (head == null) {
            return -1;
        }
        //先判断头结点是不是要找的雇员
        if (head.id == id) {
            head = head.next;
            return 1;
        }
        Emp temp = head;
        while (temp.next != null) {
            if (temp.next.id == id){
                temp.next = temp.next.next;
                return 1;
            }
            temp = temp.next;
        }
        return -1;
    }
}
```

## 9、树结构基础

### 9.1、二叉树

#### 1、为什么需要树这种结构

1）数组存储方式分析

优点：通过下标方式访问元素，速度快。**对于有序数组**，还可使用二分查找提高检索速度。
缺点：如果要检索具体某个值，或者插入值(按一定顺序)**会整体移动**，效率较低

![image-20210413165440474](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413165440474.png)

2）链式存储方式的分析

优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。
缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 

![image-20210413165527823](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413165527823.png)

3）树存储方式的分析

能提高数据**存储，读取**的效率, 比如利用 **二叉排序树**(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度

#### 2、树示意图

![image-20210413165652903](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413165652903.png)

树的常用术语(结合示意图理解):

1）节点

2）根节点

3）父节点

4）子节点

5）叶子节点 (没有子节点的节点)

6）节点的权(节点值)

7）路径(从root节点找到该节点的路线)

8）层

9）子树

10）树的高度(最大层数)

11）森林 :多颗子树构成森林

#### 3、二叉树的概念

1）树有很多种，每个节点**最多只能有两个子节点**的一种形式称为二叉树。

2）二叉树的子节点分为左节点和右节点。

![image-20210413165824148](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413165824148.png)

3）如果该二叉树的**所有叶子节点都在最后一层**，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。

![image-20210413165932775](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413165932775.png)

4）如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。

![image-20210413170046775](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413170046775.png)

#### 4、二叉树遍历的说明

使用前序、中序和后序对下面的二叉树进行遍历

1）前序遍历：**先输出父节点**，在遍历左子树，最后遍历右子树

2）中序遍历：先遍历左子树，**在输入父节点**，最后遍历右子树

3）后序遍历：先遍历左子树，在遍历右子树，**最后输出父节点**

#### 5、二叉树遍历实例

**思路说明：**

![image-20210413170524053](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413170524053.png)

**代码实现：**

```java
package com.company.tree;
import com.sun.org.apache.regexp.internal.RE;

public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        Node root = new Node(1,"宋江");
        Node node2 = new Node(2,"吴用");
        Node node3 = new Node(3,"林冲");
        Node node4 = new Node(4,"卢俊义");
        Node node5 = new Node(5,"关胜");

        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        binaryTree.setRoot(root);

        System.out.println("前序遍历");
        binaryTree.preOrder();

       System.out.println("中序遍历");
       binaryTree.infixOrder();

       System.out.println("后序遍历");
       binaryTree.postOrder();
    }
}

class BinaryTree{

    private Node root;

    public void setRoot(Node root) {
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root != null) {
            this.root.preOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    //后续遍历
    public void postOrder(){
        if (this.root != null) {
            this.root.postOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }
}

class Node{
    private int no;
    private String name;
    private Node left;
    private Node right;

    public Node(int no, String nanme) {
        this.no = no;
        this.name = nanme;
    }

    @Override
    public String toString() {
        return "node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    //前序遍历
    public void preOrder() {
        //先输出父节点
        System.out.println(this);
        //递归向左
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }
    }
    //中序遍历
    public void infixOrder() {
        //递归向左
        if (this.left != null) {
            this.left.infixOrder();
        }
        //先输出父节点
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder() {
        //递归向左
        if (this.left != null) {
            this.left.postOrder();
        }
        if (this.right != null){
            this.right.postOrder();
        }
        //先输出父节点
        System.out.println(this);
    }
}
```

#### 6、二叉树查找指定节点

**思路：**

**前序查找**

1. 先判断当前节点的no是否是要查找的
2. 如果相等，返回当前节点
3. 如果不等，判断当前节点的左子节点是否为空，如果不为空，则递归前序查找
4. 如果左递归前序查找找到节点则返回，否则继续判断，当前节点的右子节点是否为空，如果不空，则继续向右递归前序查找。

![image-20210413170832643](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210413170832643.png)

**代码实现**

```java
package com.company.tree;
import com.sun.org.apache.regexp.internal.RE;

public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        Node root = new Node(1,"宋江");
        Node node2 = new Node(2,"吴用");
        Node node3 = new Node(3,"林冲");
        Node node4 = new Node(4,"卢俊义");
        Node node5 = new Node(5,"关胜");

        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        binaryTree.setRoot(root);

        System.out.println("前序查找");
        Node resNode1 = binaryTree.preSearch(5);
        if (resNode1 != null) {
            System.out.println(resNode1);
        }else {
            System.out.println("没找到");
        }

        System.out.println("中序查找");
        Node resNode2 = binaryTree.infixSearch(5);
        if (resNode2 != null) {
            System.out.println(resNode2);
        }else {
            System.out.println("没找到");
        }

        System.out.println("后序查找");
        Node resNode3 = binaryTree.postResearch(5);
        if (resNode3 != null) {
            System.out.println(resNode3);
        }else {
            System.out.println("没找到");
        }
    }
}

class BinaryTree{

    private Node root;

    public void setRoot(Node root) {
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root != null) {
            this.root.preOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    //后续遍历
    public void postOrder(){
        if (this.root != null) {
            this.root.postOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    /**
     * 前序查找
     * @param no 查找编号
     * @return 找到的节点
     */
    public Node preSearch(int no){
        if (root != null) {
            return this.root.preSearch(no);
        }else {
            return null;
        }
    }

    /**
     * 中序查找
     * @param no 查找编号
     * @return 找到的节点
     */
    public Node infixSearch(int no) {
        if (root != null) {
            return this.root.infixSearch(no);
        }else {
            return null;
        }
    }

    /**
     * 后序查找
     * @param no 查找编号
     * @return 找到的节点
     */
    public Node postResearch(int no) {
        if (root != null) {
            return this.root.postSearch(no);
        }else {
            return null;
        }
    }
}

class Node{
    private int no;
    private String name;
    private Node left;
    private Node right;

    public Node(int no, String nanme) {
        this.no = no;
        this.name = nanme;
    }

    @Override
    public String toString() {
        return "node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    //前序遍历
    public void preOrder() {
        //先输出父节点
        System.out.println(this);
        //递归向左
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }
    }
    //中序遍历
    public void infixOrder() {
        //递归向左
        if (this.left != null) {
            this.left.infixOrder();
        }
        //先输出父节点
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder() {
        //递归向左
        if (this.left != null) {
            this.left.postOrder();
        }
        if (this.right != null){
            this.right.postOrder();
        }
        //先输出父节点
        System.out.println(this);
    }

    //前序查找

    /**
     * 前序查找
     * @param no 查找编号
     * @return 找到的节点
     */
    public Node preSearch(int no) {
        System.out.println("前序计数~~~~~");
        //先比较当前节点是不是
        if (this.no == no){
            return this;
        }
        //判断当前节点的左子节点是否为空，若不为空，则递归前序查找
        //如果左递归前序查找，找到节点，则返回
        Node resNode = null;
        if (this.getLeft() != null) {
            resNode = this.left.preSearch(no);
        }
        //左递归找到节点，返回
        if (resNode != null) {
            return resNode;
        }
        //有递归前序查找，找到节点，则返回，否则继续
        if (this.getRight() != null) {
            resNode = this.right.preSearch(no);
        }
        return resNode;
    }

    /**
     * 中序查找
     * @param no 查找编号
     * @return 找到的节点
     */
    public Node infixSearch(int no) {
        Node resNode = null;
        //判断当前节点的左子节点是否为空，如果不为空，递归中序查找
        if (this.getLeft() != null) {
            resNode = this.left.infixSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        System.out.println("中序计数~~~~~");
        //左子序列没找到，和当前节点比较，如果是则返回当前节点
        if (this.no == no) {
            return this;
        }
        //右递归中序查找
        if (this.getRight() != null) {
            resNode = this.right.infixSearch(no);
        }
        return resNode;
    }

    /**
     * 后序查找
     * @param no 查找编号
     * @return 找到的节点
     */
    public Node postSearch(int no) {

        Node resNode = null;
        if (this.getLeft() != null) {
            resNode = this.getLeft().postSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        if (this.getRight() != null) {
            resNode = this.getRight().postSearch(no);
        }
        if (resNode != null) {
            return resNode;
        }
        System.out.println("后序计数~~~~~");
        if (this.no == no) {
            return this;
        }
        return resNode;
    }
}
```

#### 7、二叉树删除节点

**要求**

1. 如果删除的节点是叶子节点，则删除该节点
2. 如果删除的节点是非叶子结点，则删除该子树

**实现逻辑**

1. 树是空树
2. 只有一个root节点 -> 将二叉树置空
3. 因为是单向二叉树，所以要判断**当前节点的子节**点是否是需要删除的节点
4. 如果当前子节点的左子节点不为空，并且左子节点就是要删除的节点，就将this.left=null；并返回（结束递归删除）
5. 如果当前子节点的右子节点不为空，并且右子节点就是要删除的节点，就将this.right=null；并返回（结束递归删除）
6. 若果第4、5步没有删除节点，那么我们就需要向左子树进行递归删除
7. 如果第六步也没有删除节点，那我们需要向右递归删除

**代码实现**

```java
class Node{
    /**
     * 删除节点
     * 1、如果删除的节点是叶子结点，则删除该节点
     * 2、如果删除的节点是非叶子结点，则删除该子树
     * @param no 需要删除的节点序号
     */
    public void deleteNode(int no) {
        //两个判断条件不能交换顺序，this.left.no可能会空指针异常
        if (this.left != null && this.left.no == no) {
            this.left = null;
            return;
        }
        if (this.right != null && this.right.no == no) {
            this.right = null;
            return;
        }
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }
}

class BinaryTree{
    /**
     * 删除节点
     * @param no 需要删除的节点序号
     */
    public void deleteNode(int no) {
        if (root != null) {
            //判断root是不是要删除的节点
            if (root.getNo() == no) {
                root = null;
            }else {
                root.deleteNode(no);
            }
        }else {
            System.out.println("空树");
        }
    }
}
```

**要求2：**

如果删除的节点是非叶子结点，现在不希望将该非叶子结点为根节点的子节点删除，需要指定规则，规则如下：

1. 如果该非叶子结点A只有一个子节点B，则子节点B代替子节点A
2. 如果该非叶子结点A有左子节点B和右子节点C，则让左子节点B代替A

**代码实现**

```java
class Node{
    public void deleteNode2(int no) {
        if (this.left != null && this.left.no == no) {
            //如果该非叶子结点有左子节点和右子节点
            //让左子节点代替该非叶子结点
            //右子节点接到左子节点的最后一个柚子节点的右边
            if (this.left.left != null) {
                Node temp = this.left.right;
                this.left = this.left.left;
                Node curNode = this.left;
                while (curNode.right != null) {
                    curNode = curNode.right;
                }
                curNode.right = temp;
            }else {
                this.left = this.left.right;
            }
            return;
        }
        if (this.right != null && this.right.no == no) {
            if (this.right.left != null) {
                Node temp = this.right.right;
                this.right = this.right.left;
                Node curNode = this.right;
                while (curNode.right != null) {
                    curNode = curNode.right;
                }
                curNode.right = temp;
            }else {
                this.right = this.right.right;
            }
            return;
        }
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }
}

class BinaryTree{
    public void deleteNode2(int no) {
        Node temp;
        if (root != null) {
            //判断root是不是要删除的节点
            if (root.getNo() == no) {
                if(root.getLeft() != null) {
                    temp = root.getRight();
                    root = root.getLeft();
                    Node curNode = root;
                    while (curNode.getRight() != null) {
                        curNode = curNode.getRight();
                    }
                    curNode.setRight(temp);

                }else {
                    root = root.getRight();
                }
            }else {
                root.deleteNode2(no);
            }
        }else {
            System.out.println("空树");
        }
    }
}
```

### 9.2、顺序二叉树

#### 1、顺序二叉树概念

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即，数组可以转换成树，树也可以转换成数组

![image-20210414161635524](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210414161635524.png)

**特点**

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子节点为 2 * n + 1
3. 第n个元素的右子节点为 2 * n + 2
4. 第n个元素的父节点为 （n - 1）/  2
5. n 表示二叉树中的第几个元素

#### 2、顺序存储二叉树遍历

**需求**

给定一个数组{1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。前序遍历的结果应当是{1,2,3,4,5,6,7}

**代码实现**

```java
package com.company.tree;

import java.util.ArrayList;

public class ArrayBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = new int[]{1,2,3,4,5,6,7};
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);
        arrayBinaryTree.preOrder();
    }
}

class ArrayBinaryTree {
    private int[] arr;

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }

    //重载preOrder
    public void preOrder(){
        preOrder(0);
    }

    /**
     * 编写一个方法，完成顺序存储二叉树的前序遍历
     * @param index 数组的下标
     */
    public void preOrder(int index) {
        //如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能打印");
        }
        //输出当前元素
        System.out.println(arr[index]);
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            preOrder(2 * index + 1);
        }
        //向右递归
        if (index * 2 + 2 < arr.length) {
            preOrder(index * 2 + 2);
        }
    }
    
     /**
     * 编写一个方法，完成顺序存储二叉树的中序遍历
     * @param index 数组的下标
     */
    public void infixOrder(int index) {
        //如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能打印");
        }
        //向左递归遍历
        if (index * 2 + 1 < arr.length) {
            infixOrder(2 * index + 1);
        }
        //输出当前元素
        System.out.print(arr[index] + ",");
        //向右递归
        if (index * 2 + 2 < arr.length) {
            infixOrder(index * 2 + 2);
        }
    }
}
```

### 9.3、线索化二叉树

#### 1、为什么需要线索化二叉树

将数列{1,3,6,8,10,14}构建成一颗二叉树

![image-20210414162913689](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210414162913689.png)

问题分析：

1. 当我们对上述的二叉树进行中序遍历时，数列为{8,3,10,1,14,6}
2. 但是6,8,10,14这几个节点的左右指针并没有完全利用
3. 为了完全利用，应用**线索二叉树**

#### 2、线索二叉树基本介绍

1. n个节点的二叉链表中含有n + 1个空指针域，利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针（这种附加的指针叫线索）
2. 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。根据线索性质的不同，线索二叉树可以分为前序线索二叉树、中序线索二叉树和后序线索二叉树。
3. 一个节点的前一个节点，称为**前驱节点**
4. 一个节点的后一个节点，称为**后继节点**

#### 3、中序线索二叉树实例

将上面的二叉树，进行中序线索二叉树

![image-20210414163626239](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210414163626239.png)

说明：当线索化二叉树后，node节点的属性left和right，有如下情况

1. left指向的是左子树，也可能是指向的前驱结点，比如①节点left指向的左子树，而⑩节点指向的就是前驱节点
2. right同理

#### 4、遍历线索化二叉树

1. 对前面的中序线索化二叉树，进行遍历

2. 分析：

   因为线索化后，各个节点指向有所变化，因此原来的遍历方式不能使用，这是需要使用新的方式遍历线索化二叉树，各个节点可以通过线性方式遍历，因此无需使用递归，遍历的次序应当与中序遍历保持一致

**代码实现**

```java
package com.company.tree.threaded;

public class ThreadedBinaryTree {
    public static void main(String[] args) {
        Node root = new Node(1,"Tom1");
        Node node2 = new Node(3,"Tom3");
        Node node3 = new Node(6,"Tom6");
        Node node4 = new Node(8,"Tom8");
        Node node5 = new Node(10,"Tom10");
        Node node6 = new Node(14,"Tom14");

        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        BinaryTree binaryTree = new BinaryTree();
        binaryTree.setRoot(root);

        binaryTree.infixOrder();

        binaryTree.threadNode();

        //测试10号节点
        Node left = node4.getLeft();
        Node right = node4.getRight();
        System.out.println("前驱节点" + left);
        System.out.println("后继节点" + right);

        binaryTree.threadedList();
    }
}

//线索话功能的二叉树
class BinaryTree{

    private Node root;
    /**
     * 为了实现线索化，需要创建一个指向当前节点的前驱节点的一个指针
     * 在递归进行线索化时，pre总是保留前一个节点
     */
    private Node pre = null;

    public void setRoot(Node root) {
        this.root = root;
    }

    /**
     * 遍历线索化二叉树
     */
    public void threadedList() {
        //存储当前遍历的节点
        Node node = root;
        while (node != null) {
            //循环找到leftType=1的节点
            //后面随着遍历而变化，当leftType == 1时，该节点是按照线索化处理后的有效节点
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            //打印当前节点
            System.out.println(node);
            //如果当前节点的右指针指向的是后继节点，就一直输出
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
            //替换遍历节点
            node = node.getRight();
        }
    }

    public void threadNode() {
        this.threadedNode(root);
    }

    /**
     * 对二叉树进行中序线索化
     * @param node 当前需要线索化的节点
     */
    public void threadedNode(Node node) {
        //不能线索化
        if (node == null) {
            return;
        }

        //线索化左子树
        threadedNode(node.getLeft());
        //线索化当前节点
        /**
         * 先处理当前节点的前驱节点
         */
        if (node.getLeft() == null) {
            //让当前节点的左指针指向前驱节点
            node.setLeft(pre);
            //修改当前节点的左指针的类型
            node.setLeftType(1);
        }
        /**
         * 处理后继节点
         */
        if (pre != null && pre.getRight() == null) {
            pre.setRight(node);
            pre.setRightType(1);
        }

        //每处理一个节点后，让当前节点是下一个节点的前驱节点
        pre = node;

        //线索化右子树
        threadedNode(node.getRight());
    }

    //前序遍历
    public void preOrder(){
        if (this.root != null) {
            this.root.preOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.root != null) {
            this.root.infixOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    //后续遍历
    public void postOrder(){
        if (this.root != null) {
            this.root.postOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

}

class Node{
    private int no;
    private String name;
    private Node left;
    private Node right;

    //0:表示指向左子树
    //1:表示指向前驱节点
    private int leftType;
    //0:表示指向右子树
    //1:表示指向后继节点
    private int rightType;

    public Node(int no, String nanme) {
        this.no = no;
        this.name = nanme;
    }

    @Override
    public String toString() {
        return "node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    //前序遍历
    public void preOrder() {
        //先输出父节点
        System.out.println(this);
        //递归向左
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }
    }
    //中序遍历
    public void infixOrder() {
        //递归向左
        if (this.left != null) {
            this.left.infixOrder();
        }
        //先输出父节点
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder() {
        //递归向左
        if (this.left != null) {
            this.left.postOrder();
        }
        if (this.right != null){
            this.right.postOrder();
        }
        //先输出父节点
        System.out.println(this);
    }

}
```

## 10、树结构实际应用

### 10.1、堆排序

见排序算法堆排序

### 10.2、赫夫曼树

#### 1、基本介绍

1. 给定n个权值作为n个[叶子结点](https://baike.baidu.com/item/叶子结点/3620239)，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。
2. 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

#### 2、几个概念

**路径**：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

**路径长度**：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

**结点的权**：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

**结点的带权路径长度**：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3

![img](http://c.biancheng.net/uploads/allimg/190427/09563Tb0-0.png)

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

#### 3、构建过程

1)从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树

2)取出根节点权值最小的两颗二叉树 

3)组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 

4)再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

#### 4、代码实现

```java
package com.company.huffmantree;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * @author zhulei
 * @create 2021-04-16 11:03
 */
public class HuffmanTree {
    public static void main(String[] args) {
        int[] arr = new int[] {13,7,8,3,29,6,1};
        Node huffmanTree = createHuffmanTree(arr);
        huffmanTree.preOrder();

    }

    public static Node createHuffmanTree(int[] arr) {
        //遍历arr
        //将arr的每个元素构建成一个Node
        //将node放入ArrayList中,方便操作
        List<Node> nodes = new ArrayList<>();
        for (int value : arr) {
            nodes.add(new Node(value));
        }

        while (nodes.size() > 1) {
            //排序
            Collections.sort(nodes);

            //取出根节点权值最小的两颗二叉树
            //取出权值最小的节点
            Node leftNode = nodes.get(0);
            //取出权值第二小的节点
            Node rightNode = nodes.get(1);

            //构建一颗新的树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;

            //从arrlist中删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);

            //将parent加入到nodes
            nodes.add(parent);
        }

        //返回赫夫曼树root节点
        return nodes.get(0);
    }
}

//创建节点类
class Node implements Comparable<Node>{

    int value;
    Node left;
    Node right;

    //前序遍历
    public void preOrder() {
        System.out.println(this.value);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
```

### 10.3、赫夫曼编码

#### 1、基本介绍

1)赫夫曼编码也翻译为 **[ 哈夫曼](https://baike.baidu.com/item/哈夫曼)**编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法

2)赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。

3)赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间

4)赫夫曼码是可变[字长](https://baike.baidu.com/item/字长/97660)编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

#### 2、原理剖析

**通信领域中信息的处理方式1-定长编码**

•i like like like java do you like a java    // 共40个字符(包括空格) 

•105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 //对应Ascii码

•01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 //对应的二进制

•按照二进制来传递信息，总的长度是 359  (包括空格)

**通信领域中信息的处理方式2-变长编码**

•i like like like java do you like a java    // 共40个字符(包括空格)

•d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数

•0= , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d
 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.

•按照上面给各个字符规定的编码，则我们在传输 "i like like like java do you like a java" 数据时，编码就是 
 10010110100... 

字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码

**通信领域中信息的处理方式3-赫夫曼编码**

•i like like like java do you like a java    // 共40个字符(包括空格)

•d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数

按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值

![image-20210416155805463](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210416155805463.png)

//根据赫夫曼树，给各个字符，规定编码 ， 向左的路径为0，向右的路径为1 ， 编码如下:

o: 1000	u: 10010	d: 100110	y: 100111	i: 101	a : 110   k: 1110  e: 1111    j: 0000    v: 0001

l: 001     : 01

按照上面的赫夫曼编码，我们的"i like like like java do you like a java"  字符串对应的编码为 (注意这里我们使用的无损压缩)

1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110

长度为 ： 133 

说明:

1)原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%

2)此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性

**注意**

注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，**这样对应的赫夫曼编码也不完全一样**，但是wpl 是一样的，都是最小的，最后生成的赫夫曼编码的长度是一样的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:

![image-20210416155958202](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210416155958202.png)

#### 3、数据压缩（创建赫夫曼树）

**代码实现**

```java
public static Node createHuffmanTree(List<Node> nodes) {
    while (nodes.size() > 1) {
        Collections.sort(nodes);

        Node leftNode = nodes.get(0);
        Node rightNode = nodes.get(1);

        //创建一颗新的二叉树，它的根节点没有data，只有权值
        Node parent = new Node(null,leftNode.weight + rightNode.weight);
        parent.left = leftNode;
        parent.right = rightNode;

        nodes.remove(leftNode);
        nodes.remove(rightNode);

        nodes.add(parent);
    }
    return nodes.get(0);
}

/**
 * 接收字节数组，返回一个list
 * @param bytes
 * @return
 */
private static List<Node> getNodes(byte[] bytes) {

    List<Node> nodes = new ArrayList<>();

    //存储每个byte出现的次数 -》 map
    Map<Byte,Integer> counts = new HashMap<>();
    for (byte b : bytes) {
        Integer count = counts.get(b);
        //第一次出现
        if (count == null) {
            counts.put(b , 1);
        }else {
            counts.put(b,count + 1);
        }
    }

    //把每个键值对转成一个Node对象
    for (Map.Entry<Byte,Integer> entry : counts.entrySet()) {
        nodes.add(new Node(entry.getKey(),entry.getValue()));
    }

    return nodes;

}
```

#### 4、数据压缩（生成赫夫曼编码和赫夫曼编码后的数据）

1. 生成赫夫曼树对应的赫夫曼编码
2. 使用赫夫曼编码来生成赫夫曼编码数据，及按照上面的赫夫曼编码，将“i like like like java do you like a java”字符串生成读研的编码数据

**代码实现**

```java
/**
     *  将下面的方法封装，方便调用
     * @param bytes 原始字符串对用对应的byte数组
     * @return  经过赫夫曼编码处理后的数组
     */
private static byte[] huffmanZip(byte[] bytes){
    List<Node> nodes = getNodes(bytes);
    //根据nodes生成赫夫曼树
    Node huffmanTreeRoot = createHuffmanTree(nodes);
    //对应的赫夫曼编码（根据赫夫曼树）
    Map<Byte, String> codes = getCodes(huffmanTreeRoot);
    //根据赫夫曼编码，对原始数组进行压缩
    byte[] zip = zip(bytes, codes);
    return zip;
}

/**
 * 将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]
 * @param bytes 原始字符串对应的byte[]
 * @param huffmanCodes  生成的赫夫曼编码map
 * @return 返回赫夫曼编码处理后的数组
 */
private static byte[] zip(byte[] bytes,Map<Byte,String> huffmanCodes) {
    //利用huffmanCodes将bytes转成赫夫曼编码对应的字符串
    StringBuilder stringBuilder = new StringBuilder();
    //遍历bytes
    for (byte b : bytes) {
        stringBuilder.append(huffmanCodes.get(b));
    }

    //1010100010111111110010001011111111001000101111111......
    //System.out.println(stringBuilder.toString());

    //将stringBuilder转成byte[]
    int len;// = stringBuilder.length() % 8 == 0 ? stringBuilder.length() / 8 : stringBuilder.length() / 8 + 1;
    if (stringBuilder.length() % 8 == 0) {
        len = stringBuilder.length() / 8;
    }else {
        len = stringBuilder.length() / 8 + 1;
    }
    //存储压缩后的byte数组
    byte[] huffmanCodeByres = new byte[len];
    int index = 0;//记录是第几个byte
    for (int i = 0; i < stringBuilder.length(); i += 8) {
        String strByte;
        //不够8位
        if (i + 8 > stringBuilder.length()) {
            strByte = stringBuilder.substring(i);
        }else {
            strByte = stringBuilder.substring(i,i+8);
        }
        //将strByte转成一个byte，放入到cd
        huffmanCodeByres[index] = (byte) Integer.parseInt(strByte,2);
        index++;
    }
    return huffmanCodeByres;
}


//将赫夫曼编码存放在Map中
static Map<Byte,String> huffmanCodes = new HashMap<>();
//在生成赫夫曼编码表时，需要拼接路径，定义一个StringBuilding存储某个叶子结点的路径
static StringBuilder stringBuilder = new StringBuilder();

/**
 * 重载getCodes
 * @param node
 * @return
 */
public static Map<Byte,String> getCodes(Node node) {
    if (node == null) {
        return null;
    }
    getCodes(node.left,"0",stringBuilder);
    getCodes(node.right,"1",stringBuilder);
    return huffmanCodes;
}

/**
 * 将传入的Node节点的所有叶子结点的赫夫曼编码得到，并放入huffmanCOde中
 * @param node  传入的节点
 * @param code  路径：左子节点是0，右子节点是1
 * @param stringBuilder 用于拼接路径
 */
public static void getCodes(Node node,String code,StringBuilder stringBuilder) {
    StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
    //将code加入到stringBuilder2
    stringBuilder2.append(code);
    if (node != null) {
        //判断当前node是叶子结点还是非叶子结点
        if (node.data == null) {
            //递归处理
            getCodes(node.left,"0",stringBuilder2);
            getCodes(node.right,"1",stringBuilder2);
        }else {
            //找到了某个叶子结点最后
            huffmanCodes.put(node.data,stringBuilder2.toString());
        }
    }
}
```

![image-20210417101557658](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210417101557658.png)

#### 5、数据解压（使用赫夫曼编码解码）

1. 前面我们得到了赫夫曼编码和对应的编码byte[] ,即[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
2. 现在要求使用赫夫曼编码，进行解码，重新得到原来的字符串“i like like like java do you like a java”
3. 解码过程就是编码的逆向操作
4. 代码实现

```java
/**
 * 对压缩数据解码
 * @param huffmanCodes 赫夫曼编码表
 * @param huffmanBytes  赫夫曼编码得到的字节数组
 * @return 原来字符串对应的数组
 */
private static byte[] decode(Map<Byte,String> huffmanCodes,byte[] huffmanBytes) {

    //1.先得到huffmanBytes对应的二进制的字符串
    //[-88, -65, ...  --> 1010100010111...
    StringBuilder stringBuilder = new StringBuilder();
    //将byte数组转成二进制字符串
    for (int i = 0; i < huffmanBytes.length; i++) {
        //判断是不是最后一个字节
        boolean flag = (i == huffmanBytes.length - 1);
        stringBuilder.append(byteToBitString(!flag,huffmanBytes[i]));
    }

    //把字符串按照指定的赫夫曼编码进行解码
    //把赫夫曼编码表进行调换，因为要反向查询
    Map<String,Byte> map = new HashMap<>();
    for (Map.Entry<Byte,String> entry : huffmanCodes.entrySet()) {
        map.put(entry.getValue(),entry.getKey());
    }

    //创建一个集合，存放byte
    List<Byte> list = new ArrayList<>();
    for (int i = 0; i < stringBuilder.length();) {
        int count = 1;
        boolean flag = true;
        Byte b = null;

        while (flag) {
            //取出‘1’ ‘0’
            String key = stringBuilder.substring(i, i+count);
            b = map.get(key);
            if (b == null) {
                count++;
            }else {
                flag = false;
            }
        }
        list.add(b);
        i += count;
    }
    //当for循环结束后，list中就存放了所有字符
    //把list中的数据放入到byte[]并返回
    byte[] b = new byte[list.size()];
    for (int i = 0; i < b.length; i++) {
        b[i] = list.get(i);
    }
    return b;
}

/**
 * 将一个byte转成一个二进制字符串
 * @param b 传入的byte
 * @param flag 标识是否需要补高位，true：需要，false：不需要 如果是最后一个字节，无需补高位
 * @return 传入byte对应的二进制字符串（补码返回）
 */
private static String byteToBitString(boolean flag, byte b) {
    int temp = b;
    //如果是正数，补高位
    if (flag){
        temp |= 256;
    }

    String string = Integer.toBinaryString(temp);
    if (flag) {
        return string.substring(string.length()-8);
    }else {
        return string;
    }
}
```

#### 6、文件压缩

```java
/**
 *将一个文件进行压缩
 * @param srcFile   传入的希望压缩的文件的全路径
 * @param dstFile   压缩后将压缩文件放到哪个目录
 */
public static void zipFile(String srcFile, String dstFile) {
    //
    OutputStream os = null;
    FileInputStream is = null;
    ObjectOutputStream oos = null;

    try {
        //创建一个文件的输入流
        is = new FileInputStream(srcFile);
        //创建一个和原文件大小一样的byte[]
        byte[] b = new byte[is.available()];
        //读取文件
        is.read(b);
        //对源文件压缩
        byte[] huffmanBytes = huffmanZip(b);
        //创建文件的输出流
        os = new FileOutputStream(dstFile);
        //创建一个和文件输出流关联的ObjectOutputSteam
        oos = new ObjectOutputStream(os);
        //把赫夫曼编码后的字节数组写入压缩文件
        oos.writeObject(huffmanBytes);
        //以对象流的方式写入赫夫曼编码，为了以后恢复源文件时使用
        //一定要把赫夫曼编码写入压缩文件
        oos.writeObject(huffmanCodes);

    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        try {
            is.close();
            os.close();
            oos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 7、文件解压

```java
/**
 * 文件解压
 * @param zipFile   准备解压的文件
 * @param detFile   解压后将文件放到哪个目录
 */
public static void unZip(String zipFile,String detFile) {
    //定义文件的输入流
    InputStream is = null;
    //定义对象输入流
    ObjectInputStream ois = null;
    //定义文件输出流
    OutputStream os = null;

    try {
        //创建文件输入流
        is = new FileInputStream(zipFile);
        //创建和is关联的对象输入流
        ois = new ObjectInputStream(is);
        //读取byte数组 huffmanBytes
        byte[] huffmanBytes = (byte[]) ois.readObject();
        //读取赫夫曼编码表
        Map<Byte,String> codes = (Map<Byte, String>) ois.readObject();

        //解码
        byte[] bytes = decode(codes, huffmanBytes);
        //将bytes写入目标文件
        os = new FileOutputStream(detFile);
        //写数据到文件中
        os.write(bytes);
    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        try {
            os.close();
            ois.close();
            is.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 8、代码汇总

```java
package com.company.huffmancode;

import java.io.*;
import java.util.*;

/**
 * @author zhulei
 * @create 2021-04-16 16:45
 */
public class HuffmanCode {
    public static void main(String[] args) {

//        //测试压缩文件
//        String srcFile = "d://src.bmp";
//        String dstFile = "d://src.zip";
//
//        zipFile(srcFile,dstFile);
//        System.out.println("压缩文件成功");

        //测试解压文件
        String zipFile = "d://src.zip";
        String dstFile = "d://src1.png";
        unZip(zipFile,dstFile);
        System.out.println("解压完成");


//        String str = "i like like like java do you like a java";
//        byte[] contentBytes = str.getBytes();
//        System.out.println(contentBytes.length);
//
//        byte[] bytes = huffmanZip(contentBytes);
//        System.out.println(Arrays.toString(bytes));
//
//
//        List<Node> nodes = getNodes(contentBytes);
//        System.out.println(nodes);
//
//        Node huffmanTreeRoot = createHuffmanTree(nodes);
//        //preOrder(huffmanTreeRoot);
//
//        Map<Byte, String> codes = getCodes(huffmanTreeRoot);
//        //System.out.println(codes);
//
//        byte[] huffmanCodeBytes = zip(contentBytes, codes);
//        //System.out.println(Arrays.toString(huffmanCodeBytes));
//
//        byte[] sourceBytes = decode(codes, huffmanCodeBytes);
//        System.out.println(Arrays.toString(sourceBytes));
//        for (byte sourceByte : sourceBytes) {
//            System.out.print((char) sourceByte);
//        }
    }

    /**
     * 文件解压
     * @param zipFile   准备解压的文件
     * @param detFile   解压后将文件放到哪个目录
     */
    public static void unZip(String zipFile,String detFile) {
        //定义文件的输入流
        InputStream is = null;
        //定义对象输入流
        ObjectInputStream ois = null;
        //定义文件输出流
        OutputStream os = null;

        try {
            //创建文件输入流
            is = new FileInputStream(zipFile);
            //创建和is关联的对象输入流
            ois = new ObjectInputStream(is);
            //读取byte数组 huffmanBytes
            byte[] huffmanBytes = (byte[]) ois.readObject();
            //读取赫夫曼编码表
            Map<Byte,String> codes = (Map<Byte, String>) ois.readObject();

            //解码
            byte[] bytes = decode(codes, huffmanBytes);
            //将bytes写入目标文件
            os = new FileOutputStream(detFile);
            //写数据到文件中
            os.write(bytes);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            try {
                os.close();
                ois.close();
                is.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


    /**
     *将一个文件进行压缩
     * @param srcFile   传入的希望压缩的文件的全路径
     * @param dstFile   压缩后将压缩文件放到哪个目录
     */
    public static void zipFile(String srcFile, String dstFile) {
        //
        OutputStream os = null;
        FileInputStream is = null;
        ObjectOutputStream oos = null;

        try {
            //创建一个文件的输入流
            is = new FileInputStream(srcFile);
            //创建一个和原文件大小一样的byte[]
            byte[] b = new byte[is.available()];
            //读取文件
            is.read(b);
            //对源文件压缩
            byte[] huffmanBytes = huffmanZip(b);
            //创建文件的输出流
            os = new FileOutputStream(dstFile);
            //创建一个和文件输出流关联的ObjectOutputSteam
            oos = new ObjectOutputStream(os);
            //把赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(huffmanBytes);
            //以对象流的方式写入赫夫曼编码，为了以后恢复源文件时使用
            //一定要把赫夫曼编码写入压缩文件
            oos.writeObject(huffmanCodes);

        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            try {
                is.close();
                os.close();
                oos.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 对压缩数据解码
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanBytes  赫夫曼编码得到的字节数组
     * @return 原来字符串对应的数组
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes,byte[] huffmanBytes) {

        //1.先得到huffmanBytes对应的二进制的字符串
        //[-88, -65, ...  --> 1010100010111...
        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转成二进制字符串
        for (int i = 0; i < huffmanBytes.length; i++) {
            //判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length - 1);
            stringBuilder.append(byteToBitString(!flag,huffmanBytes[i]));
        }

        //把字符串按照指定的赫夫曼编码进行解码
        //把赫夫曼编码表进行调换，因为要反向查询
        Map<String,Byte> map = new HashMap<>();
        for (Map.Entry<Byte,String> entry : huffmanCodes.entrySet()) {
            map.put(entry.getValue(),entry.getKey());
        }

        //创建一个集合，存放byte
        List<Byte> list = new ArrayList<>();
        for (int i = 0; i < stringBuilder.length();) {
            int count = 1;
            boolean flag = true;
            Byte b = null;

            while (flag) {
                //取出‘1’ ‘0’
                String key = stringBuilder.substring(i, i+count);
                b = map.get(key);
                if (b == null) {
                    count++;
                }else {
                    flag = false;
                }
            }
            list.add(b);
            i += count;
        }
        //当for循环结束后，list中就存放了所有字符
        //把list中的数据放入到byte[]并返回
        byte[] b = new byte[list.size()];
        for (int i = 0; i < b.length; i++) {
            b[i] = list.get(i);
        }
        return b;
    }

    /**
     * 将一个byte转成一个二进制字符串
     * @param b 传入的byte
     * @param flag 标识是否需要补高位，true：需要，false：不需要 如果是最后一个字节，无需补高位
     * @return 传入byte对应的二进制字符串（补码返回）
     */
    private static String byteToBitString(boolean flag, byte b) {
        int temp = b;
        //如果是正数，补高位
        if (flag){
            temp |= 256;
        }

        String string = Integer.toBinaryString(temp);
        if (flag) {
            return string.substring(string.length()-8);
        }else {
            return string;
        }
    }


    /**
     *  将下面的方法封装，方便调用
     * @param bytes 原始字符串对用对应的byte数组
     * @return  经过赫夫曼编码处理后的数组
     */
    private static byte[] huffmanZip(byte[] bytes){
        List<Node> nodes = getNodes(bytes);
        //根据nodes生成赫夫曼树
        Node huffmanTreeRoot = createHuffmanTree(nodes);
        //对应的赫夫曼编码（根据赫夫曼树）
        Map<Byte, String> codes = getCodes(huffmanTreeRoot);
        //根据赫夫曼编码，对原始数组进行压缩
        byte[] zip = zip(bytes, codes);
        return zip;
    }

    /**
     * 将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]
     * @param bytes 原始字符串对应的byte[]
     * @param huffmanCodes  生成的赫夫曼编码map
     * @return 返回赫夫曼编码处理后的数组
     */
    private static byte[] zip(byte[] bytes,Map<Byte,String> huffmanCodes) {
        //利用huffmanCodes将bytes转成赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        //遍历bytes
        for (byte b : bytes) {
            stringBuilder.append(huffmanCodes.get(b));
        }

        //1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100
        //System.out.println(stringBuilder.toString());

        //将stringBuilder转成byte[]
        int len;// = stringBuilder.length() % 8 == 0 ? stringBuilder.length() / 8 : stringBuilder.length() / 8 + 1;
        if (stringBuilder.length() % 8 == 0) {
            len = stringBuilder.length() / 8;
        }else {
            len = stringBuilder.length() / 8 + 1;
        }
        //存储压缩后的byte数组
        byte[] huffmanCodeBytes = new byte[len];
        int index = 0;//记录是第几个byte
        for (int i = 0; i < stringBuilder.length(); i += 8) {
            String strByte;
            //不够8位
            if (i + 8 > stringBuilder.length()) {
                strByte = stringBuilder.substring(i);
            }else {
                strByte = stringBuilder.substring(i,i+8);
            }
            //将strByte转成一个byte，放入到cd
            huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte,2);
            index++;
        }
        return huffmanCodeBytes;
    }


    //将赫夫曼编码存放在Map中
    static Map<Byte,String> huffmanCodes = new HashMap<>();
    //在生成赫夫曼编码表时，需要拼接路径，定义一个StringBuilding存储某个叶子结点的路径
    static StringBuilder stringBuilder = new StringBuilder();

    /**
     * 重载getCodes
     * @param node
     * @return
     */
    public static Map<Byte,String> getCodes(Node node) {
        if (node == null) {
            return null;
        }
        getCodes(node.left,"0",stringBuilder);
        getCodes(node.right,"1",stringBuilder);
        return huffmanCodes;
    }

    /**
     * 将传入的Node节点的所有叶子结点的赫夫曼编码得到，并放入huffmanCOde中
     * @param node  传入的节点
     * @param code  路径：左子节点是0，右子节点是1
     * @param stringBuilder 用于拼接路径
     */
    public static void getCodes(Node node,String code,StringBuilder stringBuilder) {
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        //将code加入到stringBuilder2
        stringBuilder2.append(code);
        if (node != null) {
            //判断当前node是叶子结点还是非叶子结点
            if (node.data == null) {
                //递归处理
                getCodes(node.left,"0",stringBuilder2);
                getCodes(node.right,"1",stringBuilder2);
            }else {
                //找到了某个叶子结点最后
                huffmanCodes.put(node.data,stringBuilder2.toString());
            }
        }
    }


    /**
     * 前序遍历
     * @param root
     */
    public static void preOrder(Node root) {
        if (root != null) {
            root.preOrder();
        }else {
            System.out.println("空，无法遍历");
        }
    }

    /**
     * 创建赫夫曼树
     * @param nodes 待转换的集合
     * @return 赫夫曼树的根节点
     */
    public static Node createHuffmanTree(List<Node> nodes) {
        while (nodes.size() > 1) {
            Collections.sort(nodes);

            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);

            //创建一颗新的二叉树，它的根节点没有data，只有权值
            Node parent = new Node(null,leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            nodes.remove(leftNode);
            nodes.remove(rightNode);

            nodes.add(parent);
        }
        return nodes.get(0);
    }

    /**
     * 接收字节数组，返回一个list
     * @param bytes
     * @return
     */
    private static List<Node> getNodes(byte[] bytes) {

        List<Node> nodes = new ArrayList<>();

        //存储每个byte出现的次数 -》 map
        Map<Byte,Integer> counts = new HashMap<>();
        for (byte b : bytes) {
            Integer count = counts.get(b);
            if (count == null) {
                counts.put(b , 1);
            }else {
                counts.put(b,count + 1);
            }
        }

        //把每个键值对转成一个Node对象
        for (Map.Entry<Byte,Integer> entry : counts.entrySet()) {
            nodes.add(new Node(entry.getKey(),entry.getValue()));
        }

        return nodes;

    }
}

class Node implements Comparable<Node>{

    Byte data;//存放数据本身
    int weight;//权值
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    //前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }
}
```

#### 9、注意事项

1. 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化
2. 赫夫曼编码是按字节来处理的，因此可以处理所有的文件
3. 如果一个文件中的内容重复数据不多，压缩效果也不会很明显

### 10.4、二叉排序树

#### 1、二叉排序树介绍

**二叉排序树**：BST（Binary Sort（Search）Tree），对于二叉排序树的任何一个非叶子结点，要求**左子节点的值比当前节点的值小，右子节点的值比当前节点的值大**

**特别说明**：如果有相同的值，可以将该节点放在左子节点或右子节点

比如针对数据（7,3,1,0,12,5,1,9），对应的二叉排序树为：

![image-20210417160829949](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210417160829949.png)

#### 2、二叉排序树的创建和遍历

**代码实现**

```java
package com.company.binarysorttree;

import java.util.ArrayList;
import java.util.List;

public class binarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = new int[] {7,3,10,12,5,1,9};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }

        binarySortTree.infixOrder();
    }
}

//创建二叉排序树
class BinarySortTree{

    private Node root;

    /**
     * 添加节点
     * @param node
     */
    public void add(Node node) {
        if (root == null) {
            root = node;
        }else {
            root.add(node);
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (root != null) {
            root.infixOrder();
        }else {
            System.out.println("二叉排序树为空");
        }
    }

}

//创建Node节点
class Node{

    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    //添加节点
    //递归的形式添加节点，需要满足二叉排序树的要求
    public void add(Node node) {
        if (node == null) {
            return;
        }

        //判断传入节点的值，和当前子树的根节点的值得关系
        if (node.value < this.value) {
            if (this.left == null)  {
                this.left = node;
            }else {
                this.left.add(node);
            }
        }else {
            if (this.right == null) {
                this.right = node;
            }else {
                this.right.add(node);
            }
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }
}
```

#### 3、二叉排序树的删除

![image-20210417161225107](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210417161225107.png)

二叉排序树的删除情况比较复杂，有想三种情况需要考虑

1. 删除叶子结点（2,5,9,12）
2. 删除只有一颗子树的节点（1）
3. 删除有两颗子树的节点（7,3,10）

##### **思路分析**

**第一种情况**

删除叶子结点（2,5,9,12）

1. 先找到要删除的节点 targetNode

2. 找到 targetNode 的父节点 parent

3. 确定 targetNode 是parent 的左子节点还是右子节点

4. 根据前面的情况来对应删除

   左子节点：parent.left = null

   右子节点：parent.right = null

**第二种情况**

删除只有一颗子树的节点（1）

1. 先找到要删除的节点 targetNode

2. 找到 targetNode 的父节点 parent

3. 确定 targetNode 的子节点是左子节点还是右子节点

4. targetNode 是 parent 的左子节点还是右子节点

5. 如果 targetNode 有左子节点

   1. 如果 targetNode 是parent 的左子节点

      parent.left = targetNode.left

   2. 如果 targetNode 是parent 的右子节点

      parent.right = targetNode.left

6. 如果 targetNode 有右子节点

   1. 如果 targetNode 是parent 的左子节点

      parent.left = targetNode.right

   2. 如果 targetNode 是parent 的右子节点

      parent.right = targetNode.right

**第三种情况**

删除有两颗子树的节点（7、3、10）

1. 先找到要删除的节点 targetNode
2. 找到 targetNode 的父节点 parent
3. 从 targetNode 的右子树找到最小的节点
4. 用一个临时的变量，将最小节点的值保存
5. 删除该最小节点
6. targetNode.value = temp

##### 代码实现

```java
package com.company.binarysorttree;

import java.lang.annotation.Target;
import java.util.ArrayList;
import java.util.List;

/**
 * @author zhulei
 * @create 2021-04-17 15:40
 */
public class binarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = new int[] {7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }

        binarySortTree.infixOrder();
        System.out.println();

        //删除叶子结点
        binarySortTree.delNode(7);
        binarySortTree.infixOrder();
    }
}

//创建二叉排序树
class BinarySortTree{

    private Node root;

    /**
     * 查找要删除的节点
     * @param value
     * @return
     */
    public Node search(int value) {
        if (root == null) {
            return null;
        }else {
            return root.search(value);
        }
    }

    /**
     * 查找要删除节点的父节点
     * @param value
     * @return
     */
    public Node searchParent(int value) {
        if (root == null) {
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    /**
     *  1、返回以node为根节点的二叉排序树的最小节点的值
     *  2、删除node为根节点的二叉排序树的最小节点
     * @param node  传入的节点（当做一颗二叉排序树的根节点）
     * @return  以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node node) {
        Node temp = node;
        //循环左节点，找到最小值
        while (temp.left != null) {
            temp = temp.left;
        }
        //这时，temp指向最小节点
        delNode(temp.value);
        return temp.value;
    }

    /**
     * 1、返回以node为根节点的二叉排序树的左子树的最大节点的值
     * 2、删除node为根节点的二叉排序树的左子树的最大节点
     * @param node 传入的节点（当做一颗二叉排序树的根节点）
     * @return 以node为根节点的二叉排序树的左子树的最大节点的值
     */
    public int delLeftTreeMax(Node node) {
        Node temp = node;
        //循环右节点，找到最大值
        while (temp.right != null) {
            temp = temp.right;
        }
        delNode(temp.value);
        return temp.value;
    }

    /**
     * 删除节点
     * @param value
     */
    public void delNode(int value) {
        if (root == null) {
            return;
        }else {
            //1、先找到要删除的节点targetNode
            Node targetNode = search(value);
            //没有找到要删除的节点
            if (targetNode == null) {
                return;
            }
            //当前二叉排序树只有一个节点
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }
            //找到targetNode的父节点
            Node parent = searchParent(value);
            //targetNode是叶子结点
            if (targetNode.left == null && targetNode.right == null) {
                if (parent.left != null && parent.left.value == value) {
                    parent.left = null;
                }else if (parent.right != null && parent.right.value == value) {
                    parent.right = null;
                }
            }else if (targetNode.left!= null && targetNode.right != null) { //删除有两颗子树的节点
//                int minValue = delRightTreeMin(targetNode.right);
//                targetNode.value = minValue;
                int maxValue = delLeftTreeMax(targetNode.left);
                targetNode.value = maxValue;
            }else { //删除只有一颗子树的节点
                //要删除的节点有左子节点
                if (targetNode.left != null) {
                    if (parent != null) {
                        //targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        }else { //targetNode是parent的右子节点
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }

                }else { //要删除的节点有右子节点
                    if (parent != null) {
                        //targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        }else { //targetNode是parent的右子节点
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }
            }
        }
    }

    /**
     * 添加节点
     * @param node
     */
    public void add(Node node) {
        if (root == null) {
            root = node;
        }else {
            root.add(node);
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (root != null) {
            root.infixOrder();
        }else {
            System.out.println("二叉排序树为空");
        }
    }

}

//创建Node节点
class Node{

    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    /**
     * 查找要删除的节点
     * @param value 希望要删除的节点的值
     * @return 该节点
     */
    public Node search(int value) {
        if (value == this.value) {
            return this;
        }else if (value < this.value) {//如果查找的值小于当前节点，向左子树递归查找
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        }else {//查找的值不小于当前节点，向右子树递归
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 查找严删除节点的父节点
     * @param value 要删除的值
     * @return  要删除的节点的父节点
     */
    public Node searchParent(int value) {
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        }else {
            //如果查找的值小于当前的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right != null) {
                return this.right.searchParent(value);
            }else {
                //没有找到父节点
                return null;
            }
        }
    }

    //添加节点
    //递归的形式添加节点，需要满足二叉排序树的要求
    public void add(Node node) {
        if (node == null) {
            return;
        }

        //判断传入节点的值，和当前子树的根节点的值得关系
        if (node.value < this.value) {
            if (this.left == null)  {
                this.left = node;
            }else {
                this.left.add(node);
            }
        }else {
            if (this.right == null) {
                this.right = node;
            }else {
                this.right.add(node);
            }
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }
}
```

### 10.5、平衡二叉树（AVL树）

#### 1、二叉排序树可能存在的问题

一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在

![image-20210418154316200](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210418154316200.png)

1. 左子树全部为空，从形式上看，更像一个单链表.
2. 插入速度没有影响
3. 查询速度明显降低(因为需要依次比较), 不能发挥BST 的优势，因为每次还需要比较左子树，其查询速度比单链表还慢
4. 解决方案-平衡二叉树(AVL)

#### 2、平衡二叉树基本介绍

1. 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以**保证查询效率较高**。
2. 具有以下**特点**：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有[红黑树](https://baike.baidu.com/item/红黑树/2413209)、[AVL](https://baike.baidu.com/item/AVL/7543015)、[替罪羊树](https://baike.baidu.com/item/替罪羊树/13859070)、[Treap](https://baike.baidu.com/item/Treap)、[伸展树](https://baike.baidu.com/item/伸展树/7003945)等。

#### 3、左旋转

1、要求：创建数列{4,3,6,5,7}的平衡二叉树

2、思路分析

![image-20210418154721601](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210418154721601.png)

3、代码实现

```java
/**
 * 左旋转方法
 */
public void leftRotate() {
    //创建新节点，以当前根节点的值
    Node newNode = new Node(value);
    //把新的节点的左子树设置为当前节点的左子树
    newNode.left = this.left;
    //把新的节点的右子树设置为当前节点右子树的左子树
    newNode.right = this.right.left;
    //把当前节点的值换为右子节点的值
    this.value = this.right.value;
    //把当前节点的右子树设置成右子树的右子树
    this.right = this.right.right;
    //把当前节点的左子树设置为新节点
    this.left = newNode;
}
```

#### 4、右旋转

1、要求：创建数列{10,12,8,9,7,6}的平衡二叉树

2、思路

![image-20210418155123744](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210418155123744.png)

3、代码实现

```java
/**
 * 右旋转方法
 */
public void rightRotate() {
    //创建一个新的节点，值等于当前根节点值
    Node newNode = new Node(value);
    //把新节点的右子树设置成当前节点的右子树
    newNode.right = this.right;
    //把新节点左子树设置成当前节点左子树的右子树
    newNode.left = this.left.right;
    //把当前节点的值换成左子节点的值
    this.value = this.left.value;
    //把当前节点的左子树设置成左子树的左子树
    this.left = this.left.left;
    //把当前节点的右子树设置为新节点；
    this.right = newNode;
}
```

#### 5、双旋转

前面两个数列，进行但旋转就可以将非平衡二叉树转成平衡二叉树，但在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列{10,11,7,6,8,9}

1、问题分析

![image-20210418155402424](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210418155402424.png)

2、思路分析

1. 当符合右旋转条件时
2. 如果它的左子节点的右子树高度大于左子树高度
3. 先对当前这个节点的左子树进行左旋转
4. 再对当前节点进行右旋转即可



1. 当符合左旋转条件时
2. 如果他的右子节点的左子树高度大于右子树高度
3. 先对当前这个节点的右子树进右旋转
4. 再对当前节点进行左旋转即可

3、代码实现【AVL树完整代码】

```java
package com.company.avl;

/**
 * @author zhulei
 * @create 2021-04-18 10:01
 */
public class AVLTreeDemo {
    public static void main(String[] args) {
        //int[] arr = {4,3,6,5,7,8};
        //int[] arr = {10,12,8,9,7,6};
        int[] arr = {10,11,7,6,8,9};
        //创建一个avltree对象
        AVLTree avlTree = new AVLTree();

        for (int i = 0; i < arr.length; i++) {
            avlTree.add(new Node(arr[i]));
        }

        System.out.println("中序遍历");
        avlTree.infixOrder();

        System.out.println("树的高度" + avlTree.getRoot().height());
        System.out.println("左子树高度" + avlTree.getRoot().leftHeight());
        System.out.println("右子树高度" + avlTree.getRoot().rightHeight());
    }
}

class AVLTree{
    private Node root;

    public Node getRoot() {
        return root;
    }

    /**
     * 查找要删除的节点
     * @param value
     * @return
     */
    public Node search(int value) {
        if (root == null) {
            return null;
        }else {
            return root.search(value);
        }
    }

    /**
     * 查找要删除节点的父节点
     * @param value
     * @return
     */
    public Node searchParent(int value) {
        if (root == null) {
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    /**
     *  1、返回以node为根节点的二叉排序树的最小节点的值
     *  2、删除node为根节点的二叉排序树的最小节点
     * @param node  传入的节点（当做一颗二叉排序树的根节点）
     * @return  以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node node) {
        Node temp = node;
        //循环左节点，找到最小值
        while (temp.left != null) {
            temp = temp.left;
        }
        //这时，temp指向最小节点
        delNode(temp.value);
        return temp.value;
    }

    /**
     * 1、返回以node为根节点的二叉排序树的左子树的最大节点的值
     * 2、删除node为根节点的二叉排序树的左子树的最大节点
     * @param node 传入的节点（当做一颗二叉排序树的根节点）
     * @return 以node为根节点的二叉排序树的左子树的最大节点的值
     */
    public int delLeftTreeMax(Node node) {
        Node temp = node;
        //循环右节点，找到最大值
        while (temp.right != null) {
            temp = temp.right;
        }
        delNode(temp.value);
        return temp.value;
    }

    /**
     * 删除节点
     * @param value
     */
    public void delNode(int value) {
        if (root == null) {
            return;
        }else {
            //1、先找到要删除的节点targetNode
            Node targetNode = search(value);
            //没有找到要删除的节点
            if (targetNode == null) {
                return;
            }
            //当前二叉排序树只有一个节点
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }
            //找到targetNode的父节点
            Node parent = searchParent(value);
            //targetNode是叶子结点
            if (targetNode.left == null && targetNode.right == null) {
                if (parent.left != null && parent.left.value == value) {
                    parent.left = null;
                }else if (parent.right != null && parent.right.value == value) {
                    parent.right = null;
                }
            }else if (targetNode.left!= null && targetNode.right != null) { //删除有两颗子树的节点
//                int minValue = delRightTreeMin(targetNode.right);
//                targetNode.value = minValue;
                int maxValue = delLeftTreeMax(targetNode.left);
                targetNode.value = maxValue;
            }else { //删除只有一颗子树的节点
                //要删除的节点有左子节点
                if (targetNode.left != null) {
                    if (parent != null) {
                        //targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        }else { //targetNode是parent的右子节点
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }

                }else { //要删除的节点有右子节点
                    if (parent != null) {
                        //targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        }else { //targetNode是parent的右子节点
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }
            }
        }
    }

    /**
     * 添加节点
     * @param node
     */
    public void add(Node node) {
        if (root == null) {
            root = node;
        }else {
            root.add(node);
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (root != null) {
            root.infixOrder();
        }else {
            System.out.println("二叉排序树为空");
        }
    }
}

//创建Node节点
class Node{

    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    /**
     * 返回左子树的高度
     * @return 左子树的高度
     */
    public int leftHeight() {
        if (left == null) {
            return 0;
        }
        return left.height();
    }

    public int rightHeight() {
        if (right == null) {
            return 0;
        }
        return right.height();
    }

    /**
     * 返回当前节点的高度，以该节点为根节点的树的高度
     * @return
     */
    public int height() {
        return Math.max(left == null ? 0 : left.height(),right == null ? 0 : right.height()) + 1;
    }

    /**
     * 左旋转方法
     */
    public void leftRotate() {
        //创建新节点，以当前根节点的值
        Node newNode = new Node(value);
        //把新的节点的左子树设置为当前节点的左子树
        newNode.left = this.left;
        //把新的节点的右子树设置为当前节点右子树的左子树
        newNode.right = this.right.left;
        //把当前节点的值换为右子节点的值
        this.value = this.right.value;
        //把当前节点的右子树设置成右子树的右子树
        this.right = this.right.right;
        //把当前节点的左子树设置为新节点
        this.left = newNode;
    }

    /**
     * 右旋转方法
     */
    public void rightRotate() {
        //创建一个新的节点，值等于当前根节点值
        Node newNode = new Node(value);
        //把新节点的右子树设置成当前节点的右子树
        newNode.right = this.right;
        //把新节点左子树设置成当前节点左子树的右子树
        newNode.left = this.left.right;
        //把当前节点的值换成左子节点的值
        this.value = this.left.value;
        //把当前节点的左子树设置成左子树的左子树
        this.left = this.left.left;
        //把当前节点的右子树设置为新节点；
        this.right = newNode;
    }


    /**
     * 查找要删除的节点
     * @param value 希望要删除的节点的值
     * @return 该节点
     */
    public Node search(int value) {
        if (value == this.value) {
            return this;
        }else if (value < this.value) {//如果查找的值小于当前节点，向左子树递归查找
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        }else {//查找的值不小于当前节点，向右子树递归
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * 查找严删除节点的父节点
     * @param value 要删除的值
     * @return  要删除的节点的父节点
     */
    public Node searchParent(int value) {
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        }else {
            //如果查找的值小于当前的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right != null) {
                return this.right.searchParent(value);
            }else {
                //没有找到父节点
                return null;
            }
        }
    }

    //添加节点
    //递归的形式添加节点，需要满足二叉排序树的要求
    public void add(Node node) {
        if (node == null) {
            return;
        }

        //判断传入节点的值，和当前子树的根节点的值得关系
        if (node.value < this.value) {
            if (this.left == null)  {
                this.left = node;
            }else {
                this.left.add(node);
            }
        }else {
            if (this.right == null) {
                this.right = node;
            }else {
                this.right.add(node);
            }
        }

        //当添加完，如果右子树的高度-左子树的高度>1,左旋转
        if (rightHeight() - leftHeight() > 1) {
            //如果右子节点的左子树的高度大于右子树高度
            if (this.right != null && this.right.leftHeight() > this.right.rightHeight()) {
                //先对当前节点的右节点进行右旋转
                this.right.rightRotate();
            }
            leftRotate();
            return;
        }
        if (leftHeight() - rightHeight() > 1) {
            //如果左子节点的右子树高度大于左子树高度
            if (this.left != null && this.left.rightHeight() > this.left.leftHeight()){
                //先对当前节点的左节点进行左旋转
                this.left.leftRotate();
            }
            //进行右旋转
            rightRotate();
        }
    }

    /**
     * 中序遍历
     */
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }
}
```

## 11、多路查找树

### 11.1、二叉树与B树

#### 11.1.1、二叉树的问题分析

二叉树的操作效率较高，但是也存在问题，

![image-20210419094453739](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419094453739.png)

1. 二叉树需要加载到内存，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多（比如1亿），就存在如下问题
2. 问题1：在构建二叉树时，需要多次进行IO操作（海量数据存在数据库或文件中），节点海量，构建二叉树时，速度有影响
3. 问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度

#### 11.1.2、多叉树

1. 在二叉树中，每个节点有数据项，最多两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树
2. 2-3树、2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化

![image-20210419094941798](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419094941798.png)

#### 11.1.3、B树的基本介绍

B树通过重新组织节点，降低树的高度，并且减少IO读写次数来提升效率

![image-20210419095042056](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419095042056.png)

1. 如图，B树通过重新组织节点，降低了树的高度
2. 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4K），这样每个节点只需要一次IO就可以完全载入
3. 将树的度M设置为1024，在600亿个元素中最多只要4次IO操作就可以读取到想要的元素，B树（B+）广泛应用于文件存储系统及数据库系统中



### 11.2、2-3树

#### 11.2.1、2-3树是最简单的B树结构，具有如下特点

1. 2-3树的所有叶子结点都在同一层（只要是B树都满足这个条件）
2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 2-3树是由二节点和三节点构成的树

#### 11.2.2、2-3树的应用案列

将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成2-3树，并保证数据插入的大小顺序

![image-20210419095725607](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419095725607.png)

插入规则：

1. 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件）
2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。
5. 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则

#### 12.2.3、其他说明

除了2-3树，还有2-3-4树等，概念和2-3树类似，也是一种B树

![image-20210419095926756](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419095926756.png)

### 11.3、B树、B+树和B*树

#### 11.3.1、B树的介绍

B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。

前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:

![image-20210419100139636](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419100139636.png)

**B树的说明：**

1. B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4
2. B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点
3. 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.
4. 搜索有可能在非叶子结点结束
5. 其搜索性能等价于在关键字全集内做一次二分查找

#### 11.3.2、B+树的介绍

B+树是B树的变体，也是一种多路搜索树

![image-20210419100311641](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419100311641.png)

**B+树的说明：**

1. B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找
2. 所有**关键字都出现在叶子结点的链表中**（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的
3. 不可能在非叶子结点命中
4. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
5. 更适合文件索引系统
6. B树和B+树各有自己的应用场景，不能说B+树**完全比**B树好，反之亦然

#### 11.3.3、B*树的介绍

B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针

![image-20210419100447126](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419100447126.png)

**B*树的说明**

1. B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2
2. 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高



## 12、图

### 12.1、图的基本介绍

#### 12.1.1、为什么要有图

1. 前面我们学了线性表和树
2. 线性表局限于一个直接前驱和一个直接后继的关系
3. 树也只能有一个直接前驱也就是父节点
4. 当我们需要表示多对多的关系时， 这里我们就用到了图

#### 12.1.2、图的举例说明

图是一种**数据结构**，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。如图：

![image-20210419194431223](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419194431223.png)

#### 12.1.3、图的常用概念

1)顶点(vertex)

2)边(edge)

3)路径

4)无向图(右图)

![image-20210419194518585](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419194518585.png)

5)有向图

6)带权图

![image-20210419194547565](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419194547565.png)

### 12.2、图的表示方式

图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。

#### 12.2.1、邻接矩阵

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。

![image-20210419194712861](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419194712861.png)

#### 12.2.2、邻接表

1. 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.
2. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成

![image-20210419194814329](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419194814329.png)

**说明**

1)标号为0的结点的相关联的结点为 1 2 3 4

2)标号为1的结点的相关联结点为0 4，

3)标号为2的结点相关联的结点为 0 4 5

4)....

### 12.3、图的快速入门

**要求**: 代码实现如下图结构

![image-20210419194935409](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419194935409.png)

**思路分析** 

(1) 存储顶点String 使用 ArrayList 

(2) 保存矩阵 int[][] edges 

**代码实现**

```java
/**
 * 插入节点
 * @param vertex
 */
public void insertVertex(String vertex) {
    vertexList.add(vertex);
}

/**
 * 添加边
 * @param v1    表示点的小标，即是第几个顶点
 * @param v2    表示第二个顶点的下标
 * @param weight    表示这两个点的关系
 */
public void insertEdge(int v1,int v2,int weight) {
    edges[v1][v2] = weight;
    edges[v2][v1] = weight;
    numOfEdges++;
}
```

### 12.4、图的深度优先遍历

#### 12.4.1、图的遍历

所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历

#### 12.4.2、深度优先遍历基本思想

图的深度优先搜索(Depth First Search) 

1)深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完**当前结点**后首先访问**当前结点的第一个邻接结点**。

2)我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。

3)显然，深度优先搜索是一个递归的过程

#### 12.4.3、深度优先遍历算法步骤

1)访问初始结点v，并标记结点v为已访问。

2)查找结点v的第一个邻接结点w。

3)若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。

4)若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。

5)查找结点v的w邻接结点的下一个邻接结点，转到步骤3。

![image-20210419195319941](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419195319941.png)

**代码实现**

```java
/**
 * 深度优先遍历算法
 * @param isVisited
 * @param i
 */
public void dfs(boolean[] isVisited,int i) {
    //首先访问该节点，输出
    System.out.println(getValueByIndex(i) + "->");
    //将该节点置为已访问
    isVisited[i] = true;
    //查找节点i的第一个邻接节点w
    int w = getFirstNeighbor(i);
    while (w != -1) {
        if (!isVisited[w]) {
            dfs(isVisited,w);
        }
        w = getNextNeighbor(i,w);
    }
}

public void dfs() {
    //遍历所有的节点，进行dfs
    for (int i = 0; i < getNumOfVertex(); i++) {
        if (!isVisited[i]) {
            dfs(isVisited,i);
        }
    }
}
```

### 12.5、图的广度优先遍历

#### 12.5.1、广度优先遍历基本思想

图的广度优先搜索(Broad First Search) 。

类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点

#### 12.5.2、广度优先遍历算法步骤

1)访问初始结点v并标记结点v为已访问。

2)结点v入队列

3)当队列非空时，继续执行，否则算法结束。

4)出队列，取得队头结点u。

5)查找结点u的第一个邻接结点w。

6)若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：

​	6.1 若结点w尚未被访问，则访问结点w并标记为已访问。 

​	6.2 结点w入队列 

​	6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。

![image-20210419195600324](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210419195600324.png)

**代码实现**

```java
/**
 * 一个节点的广度优先遍历
 * @param isVisited
 * @param i
 */
public void bfs(boolean[] isVisited,int i) {
    //队列头结点对应的下标
    int u;
    //邻接节点w
    int w;
    //队列，记录节点访问的顺序
    LinkedList queue = new LinkedList();
    //访问这个节点
    System.out.print(getValueByIndex(i) + "->");
    //标记为已访问
    isVisited[i] = true;
    //将节点加入队列
    queue.addLast(i);
    while (!queue.isEmpty()) {
        //取出队列头结点下标
        u = (Integer) queue.removeFirst();
        //得到第一个邻接点的下标w
        w = getFirstNeighbor(u);
        while (w != -1) {
            //是否访问过
            if (!isVisited[w]) {
                System.out.print(getValueByIndex(w) + "->");
                //标记以及访问
                isVisited[w] = true;
                //入队
                queue.addLast(w);
            }
            //以u为前驱点，找w后面的下一个邻接点
            w = getNextNeighbor(u,w);//体现广度优先
        }
    }
}

/**
 * 遍历所有节点进行广度优先搜索
 */
public void bfs() {
    for (int i = 0; i < getNumOfVertex(); i++) {
        if (!isVisited[i]) {
            bfs(isVisited,i);
        }
    }
}
```

### 12.6、图代码汇总

```java
package com.company.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.concurrent.ForkJoinPool;
import java.util.function.IntPredicate;
import java.util.jar.JarEntry;

/**
 * @author zhulei
 * @create 2021-04-19 10:23
 */
public class Graph {

    //存储顶点集合
    private ArrayList<String> vertexList;
    //存储图对应的领接矩阵
    private int[][] edges;
    //表示边的数目
    private int numOfEdges;
    //定义数组boolean[]，记录某个节点是否被访问
    private boolean[] isVisited;

    public static void main(String[] args) {
        int n = 5;
        String[] Vertex = {"A","B","C","D","E"};
        Graph graph = new Graph(n);
        for (String value : Vertex) {
            graph.insertVertex(value);
        }
        //添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);

        graph.showGraph();

//        System.out.println("深度优先");
//        graph.dfs();

        System.out.println("广度优先");
        graph.bfs();
    }

    public Graph(int n) {
        //初始化矩阵和ArrayList
        edges = new int[n][n];
        vertexList = new ArrayList<>(n);
        isVisited = new boolean[n];
    }

    /**
     * 得到第一个邻接节点的下标w
     * @param index
     * @return 如果存在就返回下标，否则返回-1
     */
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    /**
     * 根据前一个邻接节点的下标来获取下一个邻接节点
     * @param v1
     * @param v2
     * @return
     */
    public int getNextNeighbor(int v1,int v2) {
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 一个节点的广度优先遍历
     * @param isVisited
     * @param i
     */
    public void bfs(boolean[] isVisited,int i) {
        //队列头结点对应的下标
        int u;
        //邻接节点w
        int w;
        //队列，记录节点访问的顺序
        LinkedList queue = new LinkedList();
        //访问这个节点
        System.out.print(getValueByIndex(i) + "->");
        //标记为已访问
        isVisited[i] = true;
        //将节点加入队列
        queue.addLast(i);
        while (!queue.isEmpty()) {
            //取出队列头结点下标
            u = (Integer) queue.removeFirst();
            //得到第一个邻接点的下标w
            w = getFirstNeighbor(u);
            while (w != -1) {
                //是否访问过
                if (!isVisited[w]) {
                    System.out.print(getValueByIndex(w) + "->");
                    //标记以及访问
                    isVisited[w] = true;
                    //入队
                    queue.addLast(w);
                }
                //以u为前驱点，找w后面的下一个邻接点
                w = getNextNeighbor(u,w);//体现广度优先
            }
        }
    }

    /**
     * 遍历所有节点进行广度优先搜索
     */
    public void bfs() {
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]) {
                bfs(isVisited,i);
            }
        }
    }

    /**
     * 深度优先遍历算法
     * @param isVisited
     * @param i
     */
    public void dfs(boolean[] isVisited,int i) {
        //首先访问该节点，输出
        System.out.println(getValueByIndex(i) + "->");
        //将该节点置为已访问
        isVisited[i] = true;
        //查找节点i的第一个邻接节点w
        int w = getFirstNeighbor(i);
        while (w != -1) {
            if (!isVisited[w]) {
                dfs(isVisited,w);
            }
            w = getNextNeighbor(i,w);
        }
    }

    public void dfs() {
        //遍历所有的节点，进行dfs
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]) {
                dfs(isVisited,i);
            }
        }
    }

    /**
     * 返回节点的个数
     * @return
     */
    public int getNumOfVertex() {
        return vertexList.size();
    }

    /**
     * 得到边的数目
     * @return
     */
    public int getNumOfEdges() {
        return numOfEdges;
    }

    public void showGraph() {
        for (int[] link : edges) {
            System.out.println(Arrays.toString(link));
        }
    }

    /**
     * 返回节点i（下标）对应的数据 0->"A" 1->"B"
     * @param i
     * @return
     */
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    /**
     * 返回v1，v2的权值
     * @param v1
     * @param v2
     * @return
     */
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    /**
     * 插入节点
     * @param vertex
     */
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    /**
     * 添加边
     * @param v1    表示点的小标，即是第几个顶点
     * @param v2    表示第二个顶点的下标
     * @param weight    表示这两个点的关系
     */
    public void insertEdge(int v1,int v2,int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
}
```

## 13、动态规划

### 13.1、动态规划题目特点

1. 计数
   - 有多少种方式走到右下角
   - 有多少种方法选出k个数使得和是sum
2. 求最大最小值
   - 从左上角走到右下角路径的最大数字和
   - 最长上升子序列长度
3. 求存在性
   - 取石子游戏，先手是否必胜
   - 能不能选出k个数使得和是sum

### 13.2、动态规划四步骤

![image-20210506093447324](https://zltyporapic.oss-cn-beijing.aliyuncs.com/typoraimgimage-20210506093447324.png)

#### 1、确定状态

- 状态在动态规划中的作用属于定海神针
- 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i] [j]代表什么
  - 类似于解数学题中，X、Y、Z代表什么
- 确定状态需要两个意识
  - 最后一步
    - 虽然不知道最优策略是什么，但是最优策略肯定是a1，a2 ... ak面值加起来是11
    - 所以总有最后的一枚硬币ak
    - 除掉这枚硬币，前面硬币的面值加起来是11- ak
    - 关键点：
      - 不关心前面的k-1枚硬币是怎么拼出11- ak的，而且现在甚至还不知道 ak 和 k，但是确定前面的硬币拼出了11- ak
      - 因为是最优策略，所以拼出11- ak的硬币数一定最少，否则就不是最优策略
  - 子问题
    - 最少用多少枚硬币可以拼出11- ak
    - 原问题是最少用多少枚硬币拼出11
    - 将原问题转化成一个子问题，而且规模更小：11- ak
    - 为了简化定义，设定状态f(x)=最少用多少枚硬币拼出x
    - 最后那枚硬币ak只能是1，2或者5
    - 如果ak = 1，f(11) 应该是f(11- 1) + 1
    - 如果ak = 2，f(11) 应该是f(11- 2) + 1
    - 如果ak = 5，f(11) 应该是f(11- 5) + 1
    - 需要求最少硬币数，所以
      - f(11) = min{ f(11 - 1) + 1 , f(11 - 2) + 1 , f(11 - 5) + 1}

### 2、转移方程

- 设状态f[x] = 最少用多少枚硬币拼出x
- 对于任意的x
  - f[x] = min{ f[x- 1] + 1 , f[x- 2] + 1 , f[x- 5] + 1}

### 3、初始条件和边界情况

- 两个问题：x - 1，x - 5或者x - 7小于0怎么办？什么时候停
- 如果拼不出Y，就定义f[Y] = 正无穷
- 初始条件f[0] = 0

### 4、计算顺序

- 初始条件f[0] = 0
- 计算f[1]，f[2] ... f[11]
- 当我们计算到f[x] 时，f[x - 1]，f[x - 2] ，f[x -5]都已经得到结果

```java
public int coinChange(int[] coins, int amount) {
    int[] f = new int[amount + 1];
    int n = coins.length;

    //初始化
    f[0] = 0;

    for (int i = 1; i <= amount; i++) {
        //如果无法拼出，将值设置为无穷大
        f[i] = Integer.MAX_VALUE;
        for (int j = 0; j < n; j++) {
            //i >= coins[j] 防止数组越下界
            //f[i - coins[j]] != Integer.MAX_VALUE 防止值过大，超出Integer的范围
            if (i >= coins[j] && f[i - coins[j]] != Integer.MAX_VALUE) {
                f[i] = Math.min(f[i - coins[j]] + 1,f[i]);
            }
        }
    }

    if (f[amount] == Integer.MAX_VALUE) {
        return -1;
    }
    return f[amount];
}
```

